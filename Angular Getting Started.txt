Course Overview
Course Overview
Hello, my name is Deborah Kurata, and I'd like to welcome you to my course, Angular: Getting Started, from Pluralsight. This beginner‑level course takes you on a journey through the basic features of Angular. It guides you down the right path, making your own journey with Angular more pleasant and productive. Along the way, we build a sample application so you can code along or use it as a reference for your own development. You'll see how Angular provides a consistent set of patterns for building components, templates, modules, and services, helping you come up to speed quickly. This course covers how to build components, how to create the user interface for your application in a template, and power it up with data binding and directives. You'll discover how to build services for logic needed across components and inject those services where they are needed. You'll learn how to send requests to a web server using HTTP and observables. And you'll see how to set up routing to navigate between the views of your application. In addition, you'll see how to use the Angular command‑line interface, or CLI, to generate, execute, test, and deploy your Angular application. By the end of this course, you will know the basics you need to get started building your own Angular applications. I hope you'll join me on this journey through Angular: Getting Started, from Pluralsight.

Introduction
Introduction
Angular is a framework for building web applications, both large and small. With Angular, you can build a website to show off your friend's collectibles, or you can build a full‑featured, enterprise‑level product management and inventory application or anything in between. Welcome to Angular: Getting Started from Pluralsight. Hi. My name is Deborah Kurata, and this course provides the basics you need to get started building an Angular application. As we journey through this course, we'll discover Angular's many features and uncover the answers to key questions, questions like what is a component, where do we put the HTML for our user interface, when should we use data binding, why do we need a service, and how, how do we build an Angular application? The who? Well, that's you. This course guides you down the right path, making your own journey with Angular more pleasant and productive. Simply stated, Angular is a JavaScript framework for building client‑side applications. These are applications that run entirely in the user's browser. We use techniques we already know including HTML and CSS to build the user interface, and we write our code in TypeScript, which is an enhanced version of JavaScript. Why Angular and not some other JavaScript framework? And there are a lot of other JavaScript frameworks out there. Angular makes our HTML more expressive. We can embed features, such as if conditions, for loops, and local variables, directly into our HTML. Angular has powerful data binding that lets us connect data directly to our UI. Angular promotes modularity. We build our applications as a set of building blocks, making it easier to create and reuse content. And Angular has built‑in support for communication with a back‑end server. This makes it easy for our web applications to get and post data or execute server‑side business logic. No wonder Angular is so popular with millions of web developers. In this first module, we examine the basic anatomy of an Angular application and dissect an Angular component. Then, we gear up for success by walking through the prerequisites and tips for getting the most from this course. We introduce the sample application that we'll build throughout the course, and we browse the roadmap of the Angular features we cover in this course. Now let's check out the anatomy of an Angular application.

Anatomy of an Angular Application
In Angular, an application is comprised of a set of components and services that provide functionality across those components, services such as accessing data from a back‑end server, performing tax calculations, or standard logging or exception handling. So the next question is, what is an Angular component? Each component has a template, which is the HTML defining a view for the application. Everything we want to display to the user is defined in a template. Think of a template as your application's user interface, or UI. Add to that a class for the code associated with a view. The class contains the properties, or data elements, available for binding to the view and methods which perform actions for the view, such as responding to a button click. Think of a component class as the code behind your user interface. The property variables hold the data to display in your UI. The methods define any logic or operations. A component also has metadata, which provides additional information about the component to Angular. As its name implies, metadata is simply extra data about a component, so a component has a UI defined with a template, associated code defined with a class, and additional information defined with metadata. If these terms remain a little abstract at this point, just hang on. In the coming modules, we'll revisit the terms, build a template with HTML, write code for a class with TypeScript, and specify the component metadata. For now, let's look at some tips for getting the most from this course.

Get the Most from This Course
First, let's talk about the prerequisites. This is a beginner‑level course, but this course assumes you have some basic knowledge of JavaScript for code, HTML for building a user interface, and Cascading Style Sheets, or CSS for styling. You don't have to have much experience, but a working knowledge of each will help you get the most from this course. Though not required, it is helpful if you've had some exposure to object‑oriented programming concepts, maybe through coding with C++, C#, Java, or PHP. But if you don't have any exposure to OOP, that's okay. You do not need any prior knowledge of Angular or TypeScript. We'll cover what you need in this course. Another way to get the most from this course is to join the discussion. Thoughts, comments, or questions as you watch this course? Use the Discussion tab on the Pluralsight page to post your feedback or get help with the course code. And follow me on Twitter. It would be great to hear about your experiences with Angular. Is the course coming at you too fast, or does it feel too slow? You can adjust the speed of the course using the options in your Pluralsight player so the speed is just right for you. When building web applications, regardless of the technologies we use, there are often lots of steps and places where things can go wrong. That's when a good checklist can come in. I'll present checklists at the end of each module, and we'll use them as a brief review of what was covered in that module. Feel free to jump ahead to the checklist if you have any problems when coding along with the demos in the module. And consider referencing these checklists as you start building your own Angular applications. Coding along on this journey is another great way to get the most from this course. Though not required, it's often helpful to try out the presented code. By the end of this course, you'll then have built a working sample application that you can use as a reference when building your own applications. So what is this sample application? Let's take a look.

Sample Application
To demonstrate the basic features of Angular, we'll build a sample application together, step by step. So you know what we're building, let's see the finished application in action. Welcome to Acme Product Management. As its name implies, this application manages our current list of products. At the top is our menu for access to the key features of the application. In a full‑featured application, there would be more options here, but we want to limit the sample application to the features we can build in this course. Clicking on the Product List option displays the Product List page. We see the page title and a table containing the list of products. If the user clicks the Show Image button, the product images appear, and the button changes to Hide Image. Click the button again to hide the images and compress the display. Notice the nice formatting of our price. And instead of a number for the rating, we display the rating in stars. Here at the top is an input box where the user can enter a filter string. When the input box contains a value, a Filtered by message appears, and the product list is filtered to only those with a product name that contains the entered string. Click on a product name to navigate to the product details. On the Product Detail page, we see the page title with the name of the product and all of the product details, including a product description, the nicely formatted price, and the star rating. Click the Back button to navigate back to the Product List page. So not a huge app, but big enough to demonstrate the basics of Angular. Now that we've seen the sample application, how do we build it? As stated earlier, an Angular application is comprised of a set of components and services that provide data and logic across those components. With that in mind, let's break the sample application into components and services. For the Welcome page, we'll build a welcome component. For the Product List page, we build a product list component. Recall that we had a nice visual display of stars for our ratings. We'll want to reuse that feature, so we'll build a separate nestable star component. Basically, we build a component for every web page, such as our Welcome page and Product List page, and we build a component for any reusable UI elements. We might build a reusable search component with the text box and search button or maybe a password confirm password component with text boxes and validation logic. We can then reuse these components within our other components. Clicking on a product in the Product List page displays the product detail, so we'll build a component for that as well and reuse the star component within the product detail component. Then we need an app component that ties our application pieces together. It is the app component that often has the menu, toolbars, and other application‑wide features, and it provides links to navigate to the other pages of the application. Since our application gets data, we want a reusable data service. This service could access a back‑end server to retrieve the product data for display. Lastly, we need an index.html file. This is the file that is downloaded by the browser when a user accesses our application. We'll talk more about that process flow later in this course. We'll build the basics of each of these pieces as we journey through this course. Now let's finish up this introductory module with a look at the roadmap for the remainder of this course.

Course Outline
We start with first things first. We'll discuss the tools will use, then walk through how to set up and run an Angular application. Next, we dive into components. We'll build the app component using a simple template and minimal component code and metadata. We'll see how to build the user interface for our application using templates, interpolation, and directives. We'll power up that user interface with data binding and nicely format our data with pipes. Then we tackle some additional component techniques. We'll define something called interfaces, encapsulate styles, and leverage lifecycle hooks to build better components. We'll see how to build a component designed to be nested within other components and how to communicate between the nested component and its container. We often have logic or data that is needed across components. We'll learn how to build services specifically for this purpose and use dependency injection to inject those services into the components that need them. Most web applications need to communicate with a back‑end server to get our post data and to execute back‑end business logic. In this module, we'll leverage HTTP to retrieve the data for our application. Our sample application displays multiple views. We'll see how to set up routing to navigate between those views. Next is Angular modules. We'll learn about and use the root Angular module throughout this course. But as the application grows, we want to separate its concerns. This course module reviews the basics of Angular modules and refactors our application into logical blocks using multiple Angular modules. Through the majority of this course, we create our components and other code manually. But spoiler alert, there is an easier way. We'll learn how to use the Angular CLI to build, test, and deploy our application. We're covering a lot of territory, but by the end of our trek, you'll have the basics you need to build your own Angular applications. Let's start our journey through Angular.

First Things First
Introduction
First things first. Before we can start coding with Angular, there are some preparatory steps. Welcome back to Angular: Getting Started, from Pluralsight. My name is Deborah Kurata, and in this module we set up what we need to work with Angular. A little preparation goes a long way toward a successful adventure. Before we take that first step on our journey with Angular, we need to gather our tools and get everything ready. In this module, we introduce TypeScript, which is the programming language we'll use. We install the tools we'll need, we set up and run our sample Angular application, and we walk through how to create an Angular application using the angular CLI. Let's get started.

TypeScript
TypeScript is the language we use when working with Angular. Because we'll use TypeScript throughout this course, let's take a moment to look at what TypeScript is all about. But first things first, let's talk about JavaScript. JavaScript is the language for the web and is executed by all browsers. The JavaScript language specification standard is officially called ECMAScript, or ES. Up Until recently, the ES versions were defined by a sequential number. ES3 is supported by older browsers. ES5 is supported by most modern browsers. The ES6 specification was renamed ES 2015 and introduced many key new features, such as classes and arrow functions, as we'll see later in this course. Since then, a new version of the specification has been released each year. Any newer JavaScript features that we use but a browser doesn't support must first be transpiled. What does that mean? Newer JavaScript features in our code must be compiled by a tool that converts the newer JavaScript syntax to comparable older syntax before the browser executes it. TypeScript as an open‑source language developed by Microsoft. It is a superset of JavaScript, meaning all JavaScript is valid TypeScript. TypeScript code transpiles to plain JavaScript. What does that mean? Code developed with TypeScript must be compiled and converted to comparable JavaScript syntax before the browser executes it. That way, we as developers get the benefits of TypeScript features during development and the browsers still get code they understand. One of the key benefits of TypeScript is its strong typing, meaning that everything has a data type. Because of this strong typing, TypeScript has great tooling, including inline documentation, syntax checking, code navigation, and advanced refactorings, so TypeScript helps us better reason about our code. And TypeScript implements the ES 2015 class‑based object orientation, plus more. It implements classes, interfaces, and inheritance. So if you have experience with an object‑oriented programming language such as C#, C++, or Java, using TypeScript may feel very natural to you. This course does not require any prior knowledge of TypeScript. I'll cover what you need as you need it. But if you want to learn more about TypeScript, check out the TypeScript Playground. This website allows you to do live coding with TypeScript, see the transpiled JavaScript, and run the result, all without installing anything. There are also several TypeScript courses in the Pluralsight library, including TypeScript: Getting Started. Again, you do not have to know TypeScript for this course. We'll learn it as we go. Now, let's install what we need to get started building our Angular application.

Installing What We Need: Editor
The first step in our journey is to install what we need, starting with a code editor. There are many editors that support TypeScript, either out of the box or with a plugin. We'll select one of the most common editors used by Angular developers, Visual Studio Code, often just called VS Code. You are welcome to use your editor of choice, but keep in mind that your experience with TypeScript will be much more pleasurable if you select an editor that understands TypeScript. If your project requires use of Visual Studio, consider learning Angular using VS Code first, then migrate your skills to Visual Studio. You'll be glad you did. So what is VS Code? It's a code editor created by Microsoft. It runs in Linux, Windows, and OS X on a Mac. It has great features that support TypeScript coding, such as auto‑completion, IntelliSense, syntax checking, and refactorings. It also integrates well with source control, such as Microsoft's TFS and GitHub. And it's free. If you don't have VS Code installed, you can download and install it from this URL. Select the install appropriate for your OS. Consider pausing the course and installing VS Code now if you don't already have it. VS Code is easy to use, and I'll demonstrate its features as we progress through this course. If you want to learn more about VS Code, check out their website or this Pluralsight course. Now that we have a code editor installed, there is one more thing we need.

Installing What We Need: npm
As we prepare for our Angular journey, there is something more to install before we begin, npm, which stands for Node Package Manager. What's that, you ask? You can think of npm as two things. First, it's an online registry or repository of open‑source and free libraries and packages. It contains many JavaScript packages, such as Angular, TypeScript, and Bootstrap, which is a web styling framework. Second, npm is a command‑line utility for interacting with that repository. We can type commands such as npm install, some library name. Npm will locate the specified library in the repository and install it on your local machine in a subfolder of the current folder named node_modules. In this illustration, I'm in the Users\Deborah folder and install a specific package, the fictitious abc package, in this example. After executing the install command, npm locates the abc package in the repository, creates a node_modules subfolder in the current folder, and installs the specified library and its dependencies in that subfolder. So npm is a repository and a command‑line utility you can use to access that repository. Npm has become the package manager for JavaScript applications. With npm, we can install libraries, packages, and applications, along with their dependencies. We'll need npm to install all the libraries for Angular. The npm command‑line utility can also execute scripts to perform tasks, such as running our application, as we'll see shortly. Before we can use npm to install other things or execute our scripts, we need to install npm. But we can't install npm directly. We install it by installing Node using this link. Let's take a look. Following this link takes us to the download page for Node, which installs npm. Angular minimally requires this version of npm. Then select the installer appropriate for your OS. Feel free to pause the course here and install Node now if you don't already have it. Installing Node installs npm. Before we move on, let's check our npm version. Open a command window in type npm ‑v, for version. Be sure you have at least this version of npm. We now have a code editor and the required version of npm installed. Do we need anything else?

Installing What We Need: package.json
Now that we have npm installed, we could use it to install everything else we need. So what else do we need? Well, we need the Angular libraries that comprise the Angular framework. We'll want the Angular CLI, which is the command line interface for Angular. We can use the CLI to generate code, execute our application, deploy to production, and much more as we'll see throughout this course. We need TypeScript, which is the language we use with Angular. And we'll want testing tools, linters, and other supporting libraries. So do we need to manually install each of these with npm? Luckily, the answer to that question is no, at least not directly. A more common practice is to define a package.json file that lists each package we need for our Angular application. And as you can see, there are many of them. We can also specify the desired version of each package. We then tell npm to use the package.json file to install all of the defined packages along with their dependencies. In the package.json file, the list of packages is divided into two parts. The dependencies list is for the packages we need for development that must also be deployed. The devDependencies list is for the packages we only need for development. The dependencies list includes the primary Angular packages along with supporting packages, such as RxJS, for working with data. The devDependencies include the Angular CLI. TypeScript is here in the devDependencies since we transpiled the code to JavaScript before deployment. And many of these are for unit code tests. By defining a package.json file for our Angular application, we ensure everyone on the team installs the appropriate packages and versions. We'll see how to install all of the packages in the package.json file as we set up our Angular application next.

Setting up the Angular Application
Before we set up and execute our sample Angular application, let's take a look at the steps we'll follow. We'll first navigate down to the project folder. The project folder is the folder that includes the package.json file. This file contains the list of all the packages that the application needs. Then, we'll run npm install to install the packages defined in the package.json file. We'll see what this looks like in a moment. If the installation completes successfully, we execute the application by running npm start. I've already generated the package.json file for the Angular application we'll build throughout this course. I've also created the support files, style sheets, and data files. These files are available in my GitHub repository at this link. Using the sample application as a starting point allows us to get going quickly building our Angular application as it already has data we can work with and style sheets prepared. But don't worry. We'll create an Angular application from scratch right after we get this sample application up and running. Let's download the sample application files now. I've navigated to my GitHub repository following the URL from the slide. If you are comfortable with Git, you can clone this repository. Otherwise, click this button to download all of the code as a single zip file. The APM‑Final folder contains the completed code for our sample application. Use these files if you want to see the end result. The APM‑Start folder contains the starter files. These are the files we will use as the starting point for building an Angular application. Also notice the CHANGELOG.md file here. It lists all of the changes made to this course and its sample code since the course was released. The links.md file contains the list of links from the course so you can simply click on them instead of typing them in. After cloning or downloading the files, copy or extract the files in the APM‑Start folder to a working directory called just APM. Your working APM folder should then look like this. Let's open the folder with a code editor. I've opened the APM working folder with VS Code. First, let's talk about the directory structure. By convention, all of our source files are under a folder called src. Under that folder is an app folder that contains the source files specific for our application. We only have a few folders and files here now, but we'll add more as we progress through this course. For applications of any size, we'll have subfolders under the app folder for each major feature in the application. The other files here are configuration and setup files, often called boilerplate files. To get us going quickly, we won't dive into all of these files now. We'll learn more about them in the Building, Testing, and Deploying with the CLI module later in this course. Before we can execute this code, we need to install all of the libraries required to develop and run our application. Where are those defined? In the package.json file here. This file contains a list of all of the application's dependencies. Toward the top of this file is a set of scripts. We can execute these scripts using npm. We'll learn more about these scripts throughout this course. For now, let's install all of these libraries. First, open a command prompt or terminal. VS Code has an integrated terminal we can use, View, Terminal. Next, navigate to the folder containing the package.json file. VS Code did that for us. Then type npm install. This installs all the dependencies defined in the package.json file, along with any of their dependencies. Note that you may see some warnings and messages during this installation process, like these. In most cases, you can ignore them. If you see something like this at the end, the installation completed successfully. If you see a message telling you to run a fix, don't do it. Running a fix will attempt to update the versions of some of the packages without updating all of them, which will cause errors when you try to run the application. This fixed message tells you that there are vulnerabilities and libraries that will never be deployed anyway, like the testing libraries. So ignore this message. Notice that we now have a node_modules folder here. This is where npm installed all our packages. This folder is large, so you may want to exclude it when you check your files into a source control system. Now that we have the libraries installed for our sample application, let's try running it.

Running an Angular Application
So far, we've navigated down to the project folder and successfully ran npm install to install the packages defined in the package.json file. Now we are ready to start the sample application. Remember the scripts area in our package.json file? Here is the start script. When we type npm start, it will execute the command defined here. The ng executes the Angular CLI. The string after the ng is the CLI command. The serve command builds the application and starts a local web server. That allows us to serve up the application without deploying it. The ‑o is a command option that opens the URL in our default browser. The CLI has many more commands and options. We'll see more of them as we progress through this course. Are we ready to make it go? Let's try out the start script. Back at the command prompt or terminal, type npm start. This executes the start script. If this is the first time using the Angular CLI, you will be asked if you'd like to share anonymous usage data with the Angular team. This can help the team better understand your usage scenarios. I'll answer with y, but select whichever option you prefer. The CLI then builds the application, starts a web server, and opens the URL in the default browser, which, in my case, is Chrome. Note that, by default, Angular does not support Internet Explorer or IE. For now, use a different browser. We'll talk more about Angular's IE support later in this course. If all is well, the application appears in the browser and displays some text as shown here. If the text does not appear or you see errors in the console, ensure that you ran npm install successfully as defined in the prior clip. As you can see, our application doesn't look like much, but we'll improve it on our trek through Angular. I've moved the windows around so that we could see the editor, the browser, and the terminal window. Let's see what happens when we make a code change. In the editor, open the app.component.html file. Don't worry too much about the syntax here yet. We'll talk about it shortly. For now, we'll just change the welcome text. We immediately see here that our code is recompiled, the browser refreshes, and our updated text appears. So anytime we make a change to our application, we'll be able to immediately see the effect of that change. That will be helpful. When we are finished working with our files, we can close the browser, but the server keeps running. To stop it, go back to the command prompt or terminal and press Ctrl+C and y for yes. Then, you can exit. Any time you want to run the application and keep it running to watch the effect of your code changes, simply open the terminal and use npm start again. So now we know how to build and run our code. Yay! You may have noticed that I didn't save the file after I made the code change. When using VS Code, we can set it to automatically save our changes. Here, under File, Preferences, Settings, Workspace settings, I have it set to automatically save after a short delay. Nice. Now that we have the sample application up and running, let's see how to create a new Angular application.

Creating an Angular Application Using the Angular CLI
In this demo, we'll create a new Angular application from scratch using the Angular CLI. Here again is the sample application we just installed. The Angular CLI is included in the package.json file, so it was installed locally for this Angular project. That allows us to use the CLI to launch the application with npm start, which executes ng serve using the locally installed version of the Angular CLI. But if we open the terminal and try to execute ng serve directly, we see an error. The ng command is not recognized. It is not currently a global command, so we have no way to use it to create a new Angular application. To use the ng command directly, we need to install it globally. Let's close VS Code and open a command prompt. At the command prompt, we install the Angular CLI globally using npm install ‑g for a global install @angular/cli. If it is successful, you should see a message like this showing you the installed version of the Angular CLI. With the CLI installed globally, we can use the ng command from anywhere. We are now ready to create a new Angular application. Navigate down to a desired folder for the new application. I'll put mine here. Then type ng for the Angular CLI, new to create a new Angular application, then the name of the new application. Let's call it apm‑new so we don't get it confused with our APM sample application we installed earlier. We use the ‑‑prefix command to define a prefix of pm for product management. We'll talk more about where the prefix is used shortly. The CLI then asks us several questions. It asks if we want to add Angular routing. We'll talk about routing later in this course. So for now, let's say no. Lastly, it asks which style sheet format that we want to use. The arrow keys move the selection. Let's stick with CSS. Click Enter to continue. The Angular CLI starts generating all of the setup and configuration files required for the Angular application. We'll go through each of these files in the Angular CLI module later in this course. It also creates the package.json file for the application and then automatically installs all of the package files. Looks like it's done. Let's navigate down to the apm‑new folder that the Angular CLI created for the application. If we list this directory, we see the files and folders that the CLI generated. Type code space dot to open the project in VS Code. Once in VS Code, open the terminal and type npm start to start the application. Since this is the first time we are using the CLI for this project, it again asks if we want to share our usage data. I'll say yes. It then compiles the application and generates the application bundles. Ctrl+click this link to open the application in the browser. And here it is, our new Angular application. After you've finished with this course, feel free to come back to this application and try out some of these links. But for now, let's go back to the sample application we installed earlier. In VS Code, use File, Open Recent, and select the original APM sample application. This sample application contains additional files that we'll need for the demos throughout the remainder of this course, files such as styles and data for the application.

Summary
In this module we introduced TypeScript. TypeScript has all of the productivity features of newer versions of JavaScript, plus strong typing for better tooling. Next, we installed what we need. We installed VS Code as our code editor and installed Node, which installed npm, or Node Package Manager. We downloaded the starter files from my GitHub repository, then used npm to install the packages for the application, as defined in the package.json file. We then saw how to open the sample application in VS Code and use npm scripts to run that application. Lastly, we installed the Angular CLI globally and created a new Angular application from scratch. We install the Angular CLI globally so we have access to the ng commands from any folder. As new versions of Angular are released, we can update the globally installed Angular CLI. Angular installs the CLI in each Angular project. This ensures the locally installed version of the CLI matches the version of the project over time. Recall the architecture for the sample application we're building? We outlined it in the first module. Since I used the Angular CLI to create the starter files, the CLI created the index.html file and our root app component. In the next module we'll examine components and start writing some Angular code.

Introduction to Components
Introduction
In the last module, we set up the infrastructure for our Angular application. Now we are ready to build our first component. Welcome back to Angular: Getting Started from Pluralsight. My name is Deborah Kurata, and in this module, we walk through building a very basic component with a focus on clearly defining the component's parts, their meaning, and their purpose. We can think of are Angular application as a set of components. We create each component, then arrange them to form our application. If all goes well, those components work together in harmony to provide the user with a great experience. In this module, we take a closer look at what an Angular component is and examine the code we need to build one. We walk through how to create the components class and how and why we need to define metadata. We look at how to import what we need, and we discover how to bootstrap the app component to bring our application to life. We'll continue to add to this application throughout this course. Lastly, we discuss what to do if something goes wrong. Looking again at our application architecture that we defined in the first module, I had used the Angular CLI to create the initial content for my starter files, including the index.html file and the app component, which I then updated for our sample application. In this module, we'll rebuild this app component. Let's get started.

What Is a Component?
An Angular component includes a template, which lays out the user interface fragment defining a view for the application. It is created with HTML and defines what is rendered on the page. We use Angular binding and directives in the HTML to power up the view. We'll cover binding and directives in a later module. Add to that a class for the code associated with the view. The class is created with TypeScript. The class contains the properties or data elements available for use in the view. For example, if we want to display a title in the view, we define a class property for that title. The class also contains methods, which are the functions for the logic needed by the view. For example, if we want to show and hide an image, we'd write the logic in a class method. A component also has metadata, which provides additional information about the component to Angular. It is this metadata that defines this class as an Angular component. The metadata is defined with a decorator. A decorator is a function that adds metadata to a class, its members, or its method arguments. So a component is a view defined in a template, its associated code defined with the class, and metadata defined with a decorator. Want to see what a component looks like in TypeScript? Here is a simple component. It might look complex at first, so let's break this component into chunks, starting at the bottom. Here is our class. It defines the properties and methods needed by our view. Here is the component decorator that defines the metadata. The metadata includes the template that lays out the view managed by this component. And here we import the members that we need. Let's examine each of these chunks in more detail, starting at the bottom with a class.

Creating the Component Class
If you have done any object‑oriented programming in languages such as C#, VB.NET, Java, or C++, this code should look familiar. A class is a construct that allows us to create a type with properties that define the data elements and methods that provide functionality. We define a class using the class keyword followed by the class name. A common Angular convention is to name each component class with a feature name, then append the word component as the suffix. Also by convention, the root component for an application is called AppComponent as shown here. This class name is used as the component name when the component is referenced in code. The export keyword here at the front exports this class, thereby making it available for use by other components of the application. Within the body of the class are the properties and methods. In this example, we only have one property and no methods. A property defines a data element associated with the class. We start with the property name, which by convention is a noun describing the data element. And it is in camelCase whereby the first letter of the name is lowercase. In this example, it is the title of the page. Using TypeScript's strong typing, we follow the property name with a colon and its data type. In this example, the pageTitle property is a string. We can optionally assign a default value to the property. as shown in this example. Methods are normally defined within the class body after all of the properties. Method names are often verbs that describe the action the method performs. Method names are also in camelCase, whereby the first letter of the name is lowercase. So that's it for the class. But a class alone is not enough to define a component. We need to define the template associated with this component class. How do we provide this extra information to Angular? With metadata. Let's look at that next.

Defining the Metadata with a Decorator
A class becomes an Angular component when we give it component metadata. Angular needs that metadata to understand how to instantiate the component, construct the view, and interact with the component. We define a component's metadata with the Angular component function. In TypeScript, we attach that function to the class as a decorator. A decorator is a function that adds metadata to a class, its members, or its method arguments. A decorator is a JavaScript language feature that is implemented in TypeScript. The scope of the decorator is limited to the feature that it decorates. A decorator is always prefixed with an @ sign. Angular has several built‑in decorators we use to provide additional information to Angular. We apply a decorator by positioning it immediately in front of the feature we are decorating. When decorating a class, as in this example, we define the decorator immediately above the class signature. Notice that there is no semicolon here. This syntax is similar to attributes used in other programming languages. We use the @Component decorator to identify the class as a component. Since the decorator is a function, we always add parentheses. We pass an object to the component function as indicated with the curly braces. The object we pass in has many properties. We are only using two of them here. If we plan to reference the component in any HTML, we specify a selector. The selector defines the component's directive name. A directive is simply a custom HTML tag. Whenever this directive is used in the HTML, Angular renders this component's template. We'll see how this works in the upcoming demo. A component should always have a template. Here we define the layout for the user interface fragment or view managed by this component. The double curly braces indicate data binding. We bind the h1 element value to the pageTitle property of the class. So when this HTML is rendered, the h1 element displays Acme Product Management. We'll see that in the upcoming demo as well, and we'll cover more about binding in a later module. There is one more key task before our component is complete, importing.

Importing What We Need
Before we can use a function or class that is not specifically defined in this file, we need to identify where the compiler can find that function or class. We do that with an import statement. The import statement is part of ES 2015 and implemented in TypeScript. It is conceptually similar to the import statement in Java or the C# using statement. The import statement allows us to use exported classes and functions from other files in our application, from the Angular framework, or from other external JavaScript libraries. In our example, we use the Component decorator function from Angular to define our class as a component. We need to tell Angular where to find this function. So we add an import statement and import Component from angular/core like this. We start with the import keyword. We identify the name of the member we need within curly braces. In this case, we need the Component decorator function. And we define the path to the library or file containing that member, in this case the angular/core library. If we need multiple members from the same library or file, we list them all in the imports list, separated by commas. We'll see an example of that later in this course. So this is a component. Let's now build the first component for our sample application.

Demo: Creating the App Component
In this demo, we build our app component, which is the root component for our application. Here we are in the editor with the APM folder open. This is the folder we set up in the last module from the starter files I provided. Let's open the src folder and, under, that the app folder. Since I used the Angular CLI to create the starter files, it created the root app component. It named the file app.component.ts. The file naming convention that we'll follow throughout this course is to start with the feature name. This is our root application component, so by convention, it's called app, then a dot, then the type of file, in this case component, another dot, and the extension. Since we are using TypeScript, we'll use ts as the extension. Let's open that file. In VS Code, I can click the Explorer icon to close the Explorer and see more of the code. I can reopen the Explorer by clicking the icon again. Now I'll delete the starter code for this file so we can build the app component from scratch. I like to start coding by building the class, but the order of these steps really don't matter. When we build a class, we first type in the export keyword to ensure that other parts of the application can use this class. Next, we type in the class keyword, then the name of the class. Since this is our application component class, we'll follow conventions and name it AppComponent. Inside this class, we'll define one property, the page title. We type the property name followed by a colon and the property data type, which, for the page title, is a string. Notice how IntelliSense helps us here. For this property, we want to define a default value for the page title. Next, we define the component decorator above the class. The component decorator always begins with an @ sign, then the name of the decorator, and we're using the Component decorator. The Component decorator is a function, so we type parentheses. And we're going to pass in an object, so we type in curly braces. TypeScript has underlined the Component decorator, flagging it as an error. The error is Cannot find name 'Component'. Any guesses on what the problem is? If you said that we are missing the import statement, you are right. We need to import the Component decorator from the Angular core library, import (Component) from @angular/core. When using an editor that understands TypeScript, like VS Code, we can get help with our import statements. Let's back up a moment. I'll delete the import statement and the underline reappears. Click on the underlined name, and you'll see a quickfix icon. Click it for a suggested fix. Click the entry to apply the fix and insert the import statement. Cool. In many cases, we can apply the fix even earlier. Let's delete the import statement and the Component decorator. Then, start typing the decorator again. The auto‑complete lists the Component decorator. Click on it or use the Tab key to select the entry. The editor completes the statement and automatically adds the associated import statement. Be sure to add back the parentheses for the function and the curly braces to define the passed‑in object. In the component metadata, we specify a selector for the name of the component when used as a directive in the HTML. Now that we've imported the appropriate library, we get IntelliSense for these properties. We set the selector to pm‑root. The current convention is to prefix each selector with something to identify it as part of our application. So we selected pm for product management. This is the prefix specified when creating the application with the Angular CLI as we saw in the last module. The selector ends with a name that represents this component. So we used root since this is our root app component. Next, we define the template. Any valid HTML can be specified in the template. We'll dive deeper into templates in a later module. For this example, I'll just paste in some HTML, and we're done. We have now created the first component for our application. Yay! But now that we have it, how do we use it? How do we display its template?

Bootstrapping Our App Component
You may have heard the saying pulling yourself up by your bootstraps, originally meaning to improve your situation by your own efforts. In tech, it has come to mean a self‑starting process that loads and goes. We need to tell Angular to load our root component through a process that is called bootstrapping. We first set up the index.html file to host our application. Then we define our root Angular module to bootstrap our root component. Let's look at both of these steps. Client‑side web applications often work like this. A user accesses of specific URL. The server associated with that URL is located and sent a request. The server responds by returning its default web page, index.html. The browser receives and processes that index.html file. For an Angular application, the index.html file contains script tags referencing the application files that were transpiled and bundled into several JavaScript files. These application files are then downloaded to and processed by the browser, and the application's main page appears. The index.html file contains that main page for the application. This index.html file is often the one true web page of the application. Hence, an application is often called a single‑page application or SPA. But don't worry. It will look to the user like we have lots of pages, as we saw in the demo at the beginning of this course. What we do is insert bits of HTML into the one HTML page to find an index.html. Let's see how that works. Here again is our app component just shifted to the right. Recall that the selector is the name of the component when we use it as a directive in HTML, and the template defines the HTML that we want to display. So in the index.html file, we simply add the selector where we want our template displayed. Here in the template, we call this a directive. A directive is basically a custom element. As soon as the loading is complete, the HTML defined in the component template is inserted between the selector element tags and appears on the page. But how does the Angular compiler know about this custom HTML element? It looks in an Angular module. Angular modules help us organize our application into cohesive blocks of functionality and provide boundaries within our application. They also provide a template resolution environment. What does that mean? When the Angular compiler sees a directive and a template, it looks to the Angular module for the definition. So we declare the AppComponent in an Angular module so the compiler can find it. We also use the module to bootstrap our startup component, which is our AppComponent. And we want our application to work correctly in the browser, so we add Angular's BrowserModule to our Angular module's imports. Okay, pictures are nice, but what does that look like in code? Here is our application's root Angular module. As with most everything in Angular, we define an Angular module using a class. We identify the class as an Angular module by attaching the NgModule decorator and passing in metadata, defining the details of this Angular module. For the NgModule decorator, the properties are arrays. In the declarations array, we define which of our components belong to this module. By convention, our root application component, AppComponent, belongs to the applications root Angular module, AppModule. So we declare it here. We can add other components here as well. We'll cover best practices for organizing our application into Angular modules later in this course. For now, all of our components will be declared here. In the import array, we define the external modules that we want to have available to all of the components that belong to this Angular module. External modules could be modules provided by Angular, a third party, or our own Angular modules. Here we import BrowserModule, which every browser application must import. BrowserModule registers important application service providers, such as error handling. The bootstrap array defines the startup component of the application, which is our AppComponent. The startup component should contain the selector we use in the index.html file, which, in this case, it does. Now let's check it out in the sample application.

Demo: Bootstrapping Our App Component
In this demo, we'll set up index.html to host our application and examine the root Angular module that bootstraps our AppComponent. Here we are back with our sample application exactly how we left it. Since I used the Angular CLI to create these starter files, the index.html file is already hosting our AppComponent, and the app.module.ts file already bootstraps our AppComponent. Let's take a look starting with the index.html file. To host our application, we use the component selector as a directive here within the body element. We can think of a directive as simply a custom HTML tag. Since I used the Angular CLI to create the starter files, the directive is already included here. Now let's open the app.module.ts file. Here is the class, and here is the NgModule decorator defining this class as an Angular module. The declarations array declares the AppComponent so that Angular can locate its selector. The imports array includes BrowserModule so the application runs correctly in the browser. And the bootstrap array lists our AppComponent as the starting component for our application. Looks like we are ready to run. We saw in the last module how to start the application by typing npm start in a terminal or command window. When the root AppComponent is loaded, the HTML from our component appears, and the binding in that HTML is replaced with the value of our PageTitle property. We now have a working, albeit very small, application. Before closing the browser, let's take a moment and look at the browser developer tools. In Chrome, I'll press F12. The exact tools you see here depend on the browser you are using. I'm using Chrome. Most modern browsers provide a Console tab as part of the development tools. This is always the first place to look if the page does not appear as expected or doesn't appear at all. Errors, warnings, and other information is displayed here. Use the Elements tab or DOM Explorer to view the HTML displayed in the page. This is a depiction of the DOM or document object model. The document object model is a document model loaded into the browser and represents our HTML as a node tree where each node is a part of our HTML. Notice these scripts listed here. These aren't in our source index.html file. We'll talk about these bundles, what they are and how they got here, in the Building, Testing, and Deploying with the CLI module later in this course. Here is our selector tag. Open the selector tag, and we see the HTML that we defined in our components template. This view is a great way to see the HTML for the rendered page. There is also a debugger option available here on the Sources tab to view and debug our code. Since the Angular CLI uses Webpack, our TypeScript files are listed under the webpack node here. And because the Angular CLI serve feature generates the map files, we can debug our TypeScript code directly. We can set a breakpoint, refresh the browser, and it hits that breakpoint. We can step through and check the value of any of our properties. Click here to resume. Use these debugging features anytime you need them. Before we move on, let's talk about what to do if something goes wrong.

Something's Wrong!
Because browsers don't understand the components and templates we build, Angular applications require a compile process to convert our templates and TypeScript code into JavaScript. If that compiler finds any HTML elements or code it doesn't understand, it displays a syntax error. In this example, I misspelled string. In both Angular and TypeScript, casing matters. That means that a property variable declared pagetitle with a lower case p is not the same as a property declared pageTitle with an uppercase P. The same is true for all the keywords, class and function names, decorators, directives, and so on. Components must be declared in an Angular module. You can think of an Angular module as a project file that references all the component parts of the application. If something went wrong when adding a component, recheck your modules and ensure the component is referenced. Your code editor is often the best place to start if your application isn't working. As we saw in the demo, VS Code will add a squiggly line under any syntax it doesn't understand. Hover over the line to view details on the error. Clicking on the underlined text will display a quick‑fix icon if there is a quick‑fix available. Open the VS Code terminal to view any displayed compiler messages. If there are multiple messages in the terminal, scroll up to the first message after the last compile. Often, the first error is the root of the problem, causing the other errors. And if you see an error and don't know how to fix it, check out the list of common errors and their solutions in the Angular documentation at this link. Sometimes it helps to stop and restart the compiler. Use Ctrl+C to stop and npm start to restart. The browser's developer tools can also be helpful. The console will display errors, messages, and debug information. Again, scroll up to the first message after the last compile as that error is often the root of the problem. If you see Cannot GET in the browser, that often means an error prevented the compiler from completing. And it didn't create the JavaScript files that the browser needs, so the browser couldn't get them. If this occurs, use the VS Code terminal window to view the errors. If you see an error or the application just doesn't work, it's helpful to recheck the recent code you've written. For any HTML, be sure the tags are correctly closed and that all the Angular directives are correctly spelled and cased. Angular directives are case‑sensitive. For the TypeScript code, be sure the braces are all properly closed. Just like JavaScript, TypeScript is case‑sensitive, so ensure everything has the appropriate case. If you run into an issue while coding along with the course, leverage the Pluralsight course page. The Exercise files tab contains the code as of the end of each module and a copy of the slides. Download the code, unzip it, and locate the folder for the module you are on. Use the folder compare utility to compare the downloaded code to your code to find any differences. The Discussion tab is for questions and issues regarding this course or its code. Review posted issues or post your own. Following these suggestions should get you back on the path to success with Angular. Now let's finish up this module with some checklists we can use as we build our own components.

Checklists and Summary
Angular is all about components, so our first set of checklists are for building a component. We create a class for the component with code to support the view, we use a decorator to define the component metadata, which includes the HTML for the component's template, and we import what we need. When creating the component class, we give it a clear name. This is not only the name of the class, but the name of the component as well. Be sure to watch the casing since JavaScript is case‑sensitive. By convention, use PascalCasing, whereby every word of the name is capitalized. It is common to append Component to the end of the class name to make it clear that it is a component class. Be sure to include the export keyword on the class signature. Recall what the export keyword does? It makes the class accessible to be imported by other parts of the application. If the component view displays data, such as a title, the data element is defined as a property of the class. To leverage TypeScript's strong typing, be sure to set the appropriate data type for each property and set a default value where appropriate. Use camelCase for property names with the first letter lowercase. If the component view has functionality, such as hiding and showing an image, the logic is defined as methods in the class. Use camelCase for method names with the first letter lowercase. How do we define the metadata for our component? If you said a Component decorator, you are right. A class is not a component unless it has a Component decorator. Be sure to prefix the decorator with an @. Since a decorator is a function, add parentheses and pass in the appropriate object properties. Use the selector property to define the name of the component when used as a directive in HTML. Be sure to prefix the selector for clarity. Note that the selector property is not needed if the component is not used in any HTML, as we'll see later in this course. Use the template property in the component metadata to define the view's HTML. Since we define the HTML in a string literal, we often get no IntelliSense or syntax checking. So take care to define correct HTML syntax. We'll see alternate ways to create the template for a component in the next module. So why do we need to use import? The import statement tells Angular where to find the members that this component needs. The import statement requires the import keyword followed by the member name and path. Take care when defining the member name as it is case‑sensitive. The path to the file must be enclosed in quotes and is also case‑sensitive. And remember that we don't need to specify the file extension. Here again is our application architecture. In this module, we rebuilt the AppComponent and have the very basics of our application working. Next up, let's take a closer look at templates and how Angular can power them up with binding and directives as we start building the ProductListomponent.

Templates, Interpolation, and Directives
Introduction
To build a user interface for our application in Angular, we create a template with HTML. To really power up that user interface, we need Angular's data binding and directives. Welcome back to Angular: Getting Started from Pluralsight. My name is Deborah Kurata, and in these next two modules, we create the user interface using templates, directives, and data binding. Web applications are all about the user interface, and Angular makes it easier to build rich and powerful user interfaces. Angular gives us data binding so we can easily display information and respond to user actions. With Angular directives, we add logic to our HTML, such as if statements and for loops. And with Angular components, we build nested user interface fragments, such as an image rotator or rating stars. We've seen that an Angular component is a view defined with the template, its associated code, defined with a class, and additional information, defined with metadata, and set using a component decorator. In these next two modules, we'll focus on techniques for building the template. In this module, we evaluate the different ways we can build a template for our component and demonstrate how to create a linked template for our view. Then we'll build a component associated with that template and use it as a directive. We'll detail how to set up data binding using interpolation and display the value of our component class properties in the view. We need some basic logic in the template, so we'll leverage Angular's built‑in directives. In the next module, we'll look at additional data binding techniques. Looking at our application architecture, we currently have the index.html file and our root app component in place. So we have a working sample application, but it doesn't look like much. What we really want is a list of products. In this module, we'll begin work on the product list component to display that list of products. Let's get started.

Building a Template
In the prior module, we built an inline template for our AppComponent. We used the template property to define the template directly in the component's metadata. But this is not the only way we can build a template for our components. We can use the template property and define an inline template using a simple quoted string with single or double quotes. Or we can define an inline template with a multi‑line string by enclosing the HTML in ES 2015 back ticks. The back ticks allow composing a string over several lines, making the HTML more readable. We used this technique to build our template in the last module. There are some advantages to defining it inline template using one of these two techniques. The template is directly defined within the component, keeping the view and the code for that view in one file. It is then easy to match up our data bindings with the class properties, such as the page title in this example. However, there are disadvantages as well. When defining the html in a string, most development tools don't provide IntelliSense, automatic formatting, and syntax checking. Especially as we define more HTML in the template, these issues become challenges. In many cases, the better option is to define a linked template with the HTML in it's own file. We can then use the templateUrl property in the component metadata to define the URL of our HTML file. Let's use this technique and build a linked template for our product list view. Here is our ultimate goal for the product list view. The view has a nice heading. A Filter by box at the top allows the user to enter a string. The user‑entered string is displayed here, and the list of products is filtered to only those with a product name containing that string. The products are listed in a neat table with a nicely formatted header. The Show Image button shows an image for each product. The product name is a link that displays the product detail view, which we'll build later in this course. To make this page look nice with very little effort, we use the Twitter Bootstrap styling framework. If you want to find out more about Bootstrap, check out this link. And for the stars, we use the Font Awesome icon set and toolkit. To find out more about Font Awesome, check out this link. We'll install both of these in the upcoming demo. Now let's jump into a demo and start building the template for our product list view. First, let's install Bootstrap and Font Awesome so we can use them in our templates. Open the integrated terminal or command window. I still have the application running in this window, so I'll click plus to open another command window. Then type npm install bootstrap font‑awesome. This installs both packages. You may see some warnings here. These warnings tell us that Bootstrap requires jQuery and Popper, but we only plan to use the styling parts of Bootstrap, not the interactive features. So we don't need these dependencies. Installing the packages does not provide access to their style sheets. For that, we import the styles for these packages into our global application style sheet, which is the style.css file here. We'll import the minimized version of the styles from the Bootstrap dist/css folder and the minimized version of the styles from the font‑awesome/css folder. These style sheets are then available to any template in our application. Now we are ready to add an external template file for the product list component. By convention, each feature of the application has its own folder under the app folder. So let's add a new folder here and name it products. In that folder, we'll create the template for our product list component. By convention, the name of the template is the same name as the component with an HTML extension. We'll call our product list component product‑list.component.html. Now we are ready to create the HTML for our template. Let's start with the heading. We're using Twitter Bootstrap style classes here. In the heading, we display Product List. If you don't want to type in all of this code, you can copy it from the APM‑Final folder provided in my GitHub repository as detailed in the First Things First module earlier in this course. Next is the filter by. We define an input box for entry of the filter string, and we add text that displays the user‑entered filter. We again use Twitter Bootstrap style classes to lay out the input box and text into rows. Now let's build the table. We use Twitter Bootstrap's table style classes. We have a table header. The first column header is a button to show the product image, and here is the table body. Hmm. We definitely don't want to hard code in the products here, so let's leave the table body empty for now. So we have the start of a template defined for our component. Now what? If you said we need to build a component, you are exactly right.

Building the Component
Remember the steps for building a component that we covered in the last module? We define a class, we add a Component decorator to define the metadata and specify the template, and we import what we need. The only thing that's really different from the component we created in the last module is the template property. Here we are using templateUrl to define the location of our linked template instead of defining an HTML string. Notice the syntax of the path here. If we follow the convention of defining the template HTML file in the same folder as the associated component, we can use a relative path by specifying ./. Let's jump right back to the demo and give this a try. We are back with the sample application exactly where we left it, and we are ready to build a new component. We start by creating a new file in the products folder. We'll name it using the component naming convention, .component because it is an Angular component and .ts for the extension. Then we create the class export class ProductListComponent. We're exporting this class so it is available to other parts of the application. Next, we decorate the class with a Component decorator. It is the Component decorator that makes this class a component. And we know what that underline means. We need the import statement. Let's pass an object into the Component decorator with the appropriate properties. For the selector, we'll set pm‑products. We'll use the same prefix as in the AppComponent to distinguish the selector as part of the product management application. Then we define the templateUrl. Here, we provide the path to our HTML file. Since we defined the HTML file in the same folder as the component, we can use the ./ relative path syntax here. So now we have our template defining our view, our class which defines are associated code, and the Component decorator that defines the metadata. Our component is complete, and we're ready to use it.

Using a Component as a Directive
Here is our newly created ProductListComponent and here is the AppComponent we created earlier. Note that I've excluded some of the code here on this slide, such as the import statements and class details for a better fit. We'll see the complete code when we get back to the demo. When a component has a selector defined, as we have here, we can use the component as a directive. This means that we can insert this component's template into any other component's template by using the selector as an HTML tag like this. The ProductListComponent's template is then inserted into this location in the AppComponent's template. So this is the first step when using a component as a directive. Use the name defined in the selector as an HTML tag in another component's template. When this template is displayed, Angular looks for a component that has a selector with this name. We could have hundreds of components in our application. How does our application know where to look for this selector? The application looks to the Angular module that owns this component to find all of the directives that are visible to this component. Every Angular application must have at least one Angular module, the root application module, commonly called AppModule. Currently, our AppModule declares our root application component, AppComponent. A component must belong to one and only one Angular module. The AppModule bootstraps the application with this component so it is the first component that is loaded for our application. Our AppModule also imports the system BrowserModule to pull in the features it needs to run this application in a browser. So this is what our AppModule currently looks like. An Angular module defines the boundary or context within which the component resolves its directives and dependencies. So when a component contains a directive, Angular looks to the components module to determine which directives are visible to that component. What does that mean for us? Well, for Angular to find the pm‑products directive used in the AppComponent, the ProductListComponent must also be declared in this Angular module. This is the second step when using a component as a directive. We need to ensure that the directive is visible to any component that uses it. There are two ways to expose a directive in an Angular module. We can declare the component in the Angular module as we show here. Or if the component is already declared in another Angular module, we can import that module, similar to how we import BrowserModule here. Now let's jump back to the demo and give this a try. We are back in our sample app. We defined a selector for our ProductListComponent here so we can use it as a directive in any other component. Let's use it in the AppComponent. So instead of displaying My First Component, we'll display our new product list template here. Replace the div tags with pm‑products. Are we ready to see our result in the browser? Oh my. It failed to compile. Going back to the code, let's open the terminal window. If you have multiple terminal windows open, use this drop‑down to select the window where the application is running. Here we see the error pm‑products is not a known element. And with this error, Angular gives us a solution. If pm‑products is an Angular component, and in our case it is, then verify that it is part of this module. Ah yes, we didn't do step 2 and declare it in our application's Angular module. We'll open the AppModule and add ProductListComponent to the declarations array. Well, we're getting a squiggly line here. That means we have an error. Any guess as to what's wrong? If you said we're missing the import, you are correct. Everything we declare must be imported. Now that our syntax error is gone, let's try it again. There's our page. It's not complete, and it's not interactive yet, but we have the basics in place. Note that after a compile error, you may need to refresh the browser page or restart the compiler in order to see the changes in the browser. So we successfully used our ProductListComponent as a directive. We added the selector as the directive in the containing component's template. We declared the component to the application's Angular module. Now we are ready to power up our user interface with data binding and some built‑in Angular directives.

Binding with Interpolation
In Angular, binding coordinates communication between the components class and its template and often involves passing data. We can provide values from the class to the template for display, and the template raises events to pass user actions or user‑entered values back to the class. The binding syntax is always defined in the template. Angular provides several types of binding, and we'll look at each of them. In this module, we cover interpolation. The remaining data binding techniques are covered in the next module. The double curly braces that signify interpolation are readily recognizable. The pageTitle in this example is bound to a property in the component's class. Interpolation is a one‑way binding from the class property to the template, so the value here shows up here. Interpolation supports much more than simple properties. We can perform operations, such as concatenation or simple calculations. We use interpolation to insert the interpolated strings into the text between HTML elements as shown here. Or we can use interpolation with element property assignments as in this example. Here we assign the innerText property of the h1 element to a bound value. Both of these examples display the same result. The syntax between the interpolation curly braces is called a template expression. Angular evaluates that expression, using the component as the context. So Angular looks to the component to obtain property values or to call methods. Angular then converts the result of the template expression to a string and assigns that string to an element or directive property. So any time we want to display read‑only data, we define a property for that data in our class and use interpolation to display that data in the template. Let's give this a try. Looking at the product list template from our sample application, we hardcoded in the pageTitle here in the heading. Binding the heading to a property in the class instead of hardcoding it in the HTML makes it easier to see and change when working on the code, and we could later retrieve this text from a file or database. Let's start by adding a property in the class for the pageTitle. We'll open the component to the right and close down the explorer. Here in the class, we specify the property name. We'll call it pageTitle. And because we are using TypeScript, we define the type for this property. Lastly, we assign a default value, Product List. With the pageTitle Property in place, we can now bind to the pageTitle property in the template. We replace the hardcoded product list here with interpolation and specify the name of the property. Now when this template is displayed, Angular assigns the string value of the pageTitle property to the innerText property of this div element. And Product List will be displayed. Let's see the result in the browser. With our binding, the pageTitle appears as before. So we can confirm that it works, I've rearranged the windows so that we can see both the code and the browser. Now let's make a change to our pageTitle here, and we immediately see it in the browser. So our interpolation works. So any time we want to display the value of a component property, we simply use interpolation. Now we're ready to add some logic to our template.

Adding Logic with Directives: ngIf
We can think of a directive as a custom HTML element or attribute we use to power up and extend our HTML. We can build our own custom directives or use Angular's built‑in directives. Previously in this module, we've seen how to build a component and use it as a custom directive. We use the pm‑products directive to display our product list template. In addition to building our own custom directives, we can use Angular's built‑in directives. The built‑in Angular directives we'll look at are structural directives. A structural directive modifies the structure or layout of a view by adding, removing, or manipulating elements and their children. They help us to power up our HTML with if logic and for loops. Notice the asterisk in front of the directive name. That marks the directive as a structural directive. Let's look at ngIf first. ngIf if is a structural directive that removes or recreates a portion of the document object model tree based on an expression. So ngIf is a great way to optionally display content. For example, say we only want to show the HTML table if there are some products in an array. We use ngIf on the table element and set it to products.length. The length property provides the number of elements in the array. If the products array contains some products, the table is displayed. If the products array is empty, the table element and all of its children, including the column headers, are removed from the DOM and don't appear in the UI. But wait, how is the Angular compiler going to find this ngIf directive? Looking back at the illustration of our AppModule, we see that it imports BrowserModule. Luckily for us, BrowserModule exposes the ngIf and ngFor directives. So any component declared by the AppModule can use the ngIf or ngFor directives. With that settled, let's try out the ngIf directive. We are back in the sample application looking at the ProductListComponent and its template. We only want to display this table of products if there are some products to display. So the first thing we need is a property to hold the list of products. Where do we define that products property? In the components class, of course. We'll add a products property here. Hmm. But what is the type of this property? Well, we want an array of product instances, but we don't currently have anything that defines what a product is. We'll have a better solution in a later module. But for now, we'll just define products as an array of any. In TypeScript, we use any as the data type any time we don't know or don't care what the specific data type is. We need to populate our array, but where do we get the data? In many cases, we would communicate with a back‑end server to get this data. We'll look at how to do that later in this course. For now, we'll just hard code in a set of products. If you are coding along, consider copying a few of the products from the products.json file provided with the starter files under the api\products folder. With the products property in place, we're ready to use it in the HTML. We want to put it on the table element because that is the element we want to add or remove from the DOM. Type *ngIf= and then our expression enclosed in quotes. We only want to show the table if that list of products contains some elements. Let's see what this looks like in the browser. We see the table header so we know our table is displayed. Let's try this. Let's comment out the product data. Bring up the browser again, and we see that the table disappeared. Now if we uncomment out the product data and look again at the browser, our table reappears. With ngIf, the associated element and its children are literally added or removed from the DOM. But notice that we still aren't populating the table with our products. Let's do that next.

Adding Logic with Directives: ngFor
Another structural directive is ngFor. ngFor repeats a portion of the DOM tree once for each item in an iterable list. So we define a block of HTML that defines how we want to display a single item and tell Angular to use that block for displaying each item in the list. For example, say we want to display each product in a row of a table. We define one table row and its child table data elements. That table row element and its children are then repeated for each product in the list of products. The let keyword here creates a variable called product. We can reference this variable anywhere on this element, on any sibling element, or on any child element. And notice the of instead of in here. We'll talk more about that in a moment. For now, let's jump back to our demo. We are once again looking at the ProductListComponent and its template. Here in the table body, we want to repeat a table row for each product in the list of products. In the table body, we'll add a tr element for the table row. And in the tr element, we'll specify the ngFor, *ngFor = 'let product of products'. Next, we'll add the child elements. We'll insert a td or a table data element for each property of the product that we want to display in the table. We'll need to match them up with the table header elements. The first column displays the product image. Let's skip the image for now. We'll add that in the next module, but we'll still add the td element as a placeholder. The next table header says Product. So in this column, we want the product name. We'll use interpolation to bind to the product's name by using the local variable product and a dot to drill down to the product properties. We want product name here. How did we know that property name? Looking here at the ProductListComponent, we see the product property names here, so these are the names we use in the interpolation template expressions. Next, I'll add td elements for some of the other product properties. So for each product in our list of products, we will get a tr element for a table row and td elements for table data. Want to see how this looks in the browser? Wow, we have our products. Doesn't that look nice? Well, our price is not very well formatted, and it doesn't have a currency symbol. We'll fix that with pipes in the next module. Looking back at the component, we defined an array for our list of products. In the template, we laid out the HTML to display one product. The product is displayed in a table row with product properties in the appropriate columns. Using an ngFor structural directive, we repeat this table row and its columns for each product in the list of products. So why is this ngFor syntax product of products and not product in products? The reasoning for this has to do with ES 2015 for loops. ES 2015 has both a for...of loop and for...in loop. The for...of loop is similar to a foreach‑style loop. It iterates over an iterable object, such as an array. For example, say we have an array of persons nicknames. If we use for...of to iterate over this list, we'll see each nickname logged to the council. The for...in loop iterates over the properties of an object. When working with an array such as this example, the array indexes are enumerable properties with integer names and are otherwise identical to general object properties. So we see each array index logged to the console. To help remember the difference, think of in as iterating the index. Since the ngFor directive iterates over iterable objects, not their properties, Angular selected to use the of keyword in the ngFor expression. Now let's finish up this module with some checklists we can use as we work with templates, interpolation, and directives.

Checklists and Summary
Checklists are a great way to recheck our understanding and our work. Let's start with a template. Use an inline template when building shorter templates. Then specify the template property in the Component decorator. Use double or single quotes to define the template string, or use the ES 2015 back ticks to lay out the HTML on multiple lines. When using inline templates, there is often no design time syntax checking, so pay close attention to the syntax. Use linked templates for longer templates. Specify the templateUrl property in the Component decorator and define the path to the external template file. This one is a more visual checklist. After building the template, we build its component and learn how to use that component as a directive. Remember our steps? First, we use the directive as an element in the template for any other component. We use the directive component selector as the directive name. We then declare the component so it is available to any template associated with this Angular module. We add the component to the declarations array passed into the NgModule decorator of the Angular module. Angular's data binding was introduced in this module with a look at interpolation. Interpolation is one‑way binding from a component class property to an element property. Interpolation is defined with curly braces and a template expression. That expression can be a simple property, a concatenation, a calculation. Note that no quotes are needed when using interpolation. And we saw how to use two of Angular's structural directives, ngIf and ngFor. When using these structural directives, be sure to prefix them with an asterisk and assign them to a quoted string expression. Use ngIf to add or remove an element and its children from the DOM based on an expression. If the assigned expression is evaluated to be a true value, the element is added to the DOM. If false, the element is removed from the DOM. Use ngFor to repeat an element and its children in the DOM for each element in an iterable list. Define the local variable with let and use of, not in, when defining the ngFor expression. Here, once again, is our application architecture. In this module, we started the ProductListComponent. Next up, let's discover more of Angular's data binding features and add interactivity to the product list template.

Data Binding & Pipes
Introduction
There's more to data binding than just displaying component properties. Welcome back to Angular: Getting Started from Pluralsight. My name is Deborah Kurata, and in this module, we explore more data binding features and transform bound data with pipes. To provide a great interactive user experience, we want to bind DOM elements to component properties so the component can change the look and feel as needed. We can use bindings to change element colors or styles based on data values, update font size based on user preferences, or set an image source from a database field. And we want notification of user actions and other events from the DOM so the component can respond accordingly. For example, we respond to a click on a button to hide or show images. And sometimes we want the best of both worlds, using two‑way binding to set an element property and receive event notifications of user changes to that property. In this module, we'll use Angular's property binding to set HTML element properties in the DOM. We walk through how to handle user events, such as a button click, with event binding and how to handle user input with two‑way binding. Lastly, we'll discover how to transform bound data with pipes. And here, once again, is our application architecture. We have the first cut of our ProductListComponent, but it doesn't have any interactivity. In this module, we'll use data binding features to add interactivity to the ProductListComponent. Let's get started.

Property Binding
Property binding allows us to set a property of an element to the value of a template expression. Here is an HTML image element. We bind the source property of the image to the product's imageUrl, effectively defining the source of the image from information in our component. With property binding, the element property is enclosed in square brackets, and the template expression is enclosed in quotes. For comparison, here is a similar binding using interpolation. When using interpolation, the element property is not enclosed in square brackets, and the template expression is enclosed in curly braces with no quotes. When binding to element properties, many developers prefer using property binding over interpolation. Plus property binding allows binding two types other than strings, such as a boolean true/false value. Interpolation always assigns a string. But if you need to include the template expression as part of a larger expression, such as this example, you may need to use interpolation. Like interpolation, property binding is one way from the component to the HTML element property. It effectively allows us to control our template's DOM from our component. Let's add some property binding to our sample application. Here we are back in the editor looking at the ProductListComponent and its associated template. Let's use property binding to bind the source of our product image. We use an image element to display our product image, and we use property binding to bind the image's source or src property. So we enclose the src in square brackets. On the right side of the equals, we define the template expression in quotes. We want to bind to the product's image URL property from the ProductListComponent class. Let's also use property binding to bind the title property of the image to the product's name. Let's check out the result in the browser. Whoa, they're big, but we do see images. If we hover over an image, we see the image title. But this image is rather large for display in our table. Let's use property binding to set some style properties. Let's add properties for the image width and image margin to our component class. The imageWidth is a number, so we specify its type with a colon and then number. Let's set it to 50. The imageMargin is also a number, and we'll set it to 2. Back in the template, we use property binding to bind the image styles. We want to bind the style property width in pixels. We'll bind that to the image with property from the component class. Notice that we don't prefix this property with product because imageWidth is a property of the component class, not the product object. And we do the same with the style margin in pixels and set that to the imageMargin class property. So now we've seen how to use property binding to bind several properties of the image element to properties of the component's class. Before we look at the result, let's talk about TypeScript's type inference. To learn about TypeScript's strong typing, we've been adding data types to our properties. However, if we set a property's default value, we often don't need to specify its type. TypeScript will infer the type from its value. For example, since the pageTitle property is assigned to a string, we don't need to specify its type. TypeScript will infer it as a string. Same for the numeric values. If you use a linting tool, it may flag any properties with an unnecessary data type. Feel free to remove these unnecessary types. I'll leave them here for reference. Now looking back at the browser, our image sizes look much better, but our images are always displayed. The Show Image button doesn't work yet. To hook up the button, we need to respond to user events. Let's do that next.

Handling Events with Event Binding
So far, all of our data binding has been one way from the component to the template. But there are times we need to send information the other way to respond to user actions, for example to execute some code when the user clicks a button. A component listens for user actions using event binding. Event binding allows us to connect an event to a method in the component. Here is an HTML button element. We bind the button's click event to the toggleImage method in our component. When the user clicks the button, the binding executes the code in the toggleImage method. With event binding, the event name is enclosed in parentheses. The method name is followed by open and closing parentheses and is enclosed in quotes. Wondering where to find a list of valid HTML element events? Check out this link. The Mozilla Developer Network provides a thorough list of standard events, along with some documentation. Now let's give event binding a try. In this demo, we want to implement our showImage button. First, we define a class property that keeps track of whether the images are currently displayed. We'll call that property showImage. Since this property is true or false, we define its type as boolean. And let's set its default value to false, so the images are not displayed when the page is first loaded. Next, we build the method that the event binding will call. By convention, methods are normally created after all of the properties are defined. So we'll put it down here. Let's name the method toggleImage. Notice that TypeScript does not require any keyword, such as function. Following the method name with open and closing parentheses identifies it as a method. Our method won't have a return type, so we specify the return type as void. The body of the method simply toggles the state of the showImage property. The bang or exclamation point used here is the logical not operator. It returns false if its operand, showImage in this case, is true and true if showImage is false, basically toggling the value from true to false or false to true. Back in the template, we are ready to set up the event binding. On the button element, we define the click as the target event by enclosing it in parentheses. We assign it to our method enclosed in quotes. When the user clicks the button, the binding calls our method. So the only thing left is to actually hide or show the image. Recall how we add logic to add or remove HTML elements from the DOM? If you said the ngIf directive, you are right. We'll add ngIf to the image element. We only want this image element if the showImage flag is true. The image element will then only be added to the DOM if showImage is true. Let's see if this works. Are we ready to give it a try? Click the button, ah, and the image appears. Click the button again and the image disappears. Oh, very cool. The only odd thing is the button text. When the image is displayed, the button text should change to Hide Image. So up here where we have the button text, let's use interpolation. When showImage is true, we want the button text to say Hide Image. And when showImage is false, we want the button text to say Show Image. We accomplish this using a JavaScript conditional operator. We specify the condition, which is showImage, and a question mark. Then we specify the true expression. So when showImage is true, we want to display Hide Image. Then we add a colon and the false expression. So when showImage is false, we want it to say Show Image. Basically, we can read this syntax as if showImage is true, display Hide. Otherwise, display Show. Let's check this out in the browser. So our button text now says Show Image. If we click it, it says Hide Image. Ah, that seems a little more user friendly. Cool. Before we move on, let's talk a moment about Angular's change detection. By default, Angular is constantly watching for changes to any bound properties and listening for events. In our sample application, we have a button that shows or hides images. In the HTML for the button, we bound its click event to a method in our component, and we used interpolation to change the text of the button based on the value of a property in our component. We used the ngIf structural directive to add or remove the image element from the DOM. The showImage property is initially false, so the button text displays Show Image, and the ngIf removed the image from the display. When the user clicks the button, Angular executes the method bound to the click event. The code in the method toggles the showImage property from false, its default value, to true. Angular's change detection detects that change and automatically reevaluates all the bindings. The interpolation changes the button text from Show to Hide, and the ngIf adds the image element to the DOM, displaying the image. This is the Angular way to modify DOM elements. Now that we have our images working, let's tackle the Filter by box, and for that we need two‑way binding.

Handling Input with Two-way Binding
When working with user entry HTML elements, such as an input element, we often want to display a component property in the template and update that property as the user types. Here, we set a default listFilter took cart. And if the user changes the filter, we want the listFilter property to change as well. This process requires two‑way binding with the ngModel directive. We enclose ngModel in square brackets to indicate property binding from the component property to the input element and parentheses to indicate event binding to send a notification of the user‑entered text back to the component. We assign this directive to a component property. To help us remember which order to put the two sets of brackets, visualize a banana in a box, square brackets for the box on the outside and parentheses for the banana on the inside. Recall that a directive is custom syntax Angular provides to power up our HTML. The ngModel is an Angular directive. Each time we want to use an Angular directive in a template, we need to consider how to make that directive visible to the Angular compiler. Remember how we do that? If you said an Angular module, you are right. The illustration of our AppModule currently looks like this. We want to use the ngModel directive in our ProductListComponent, which is owned by AppModule. So in the AppModule, we need to import the appropriate system module that exposes the ngModel directive. Since the ngModel directive is most often used when building data entry forms, ngModel is part of FormsModule. So we import that here. Now the ngModel directive and any of the other Angular forms directives are visible to any component declared by AppModule, including our ProductListComponent. Now let's give this a try. We are back in the editor and looking at the ProductListComponent and its associated template. Recall that we defined a Filter by input box here and displayed the entered filter here. We'll later use the filter to filter our list of products. Let's start by adding a component class property for the listFilter. This property is a string, and we'll set a default initial value for filtering the list of products. We hard code the filter string here, but you can imagine that we store the users last entered filter and use that as the default instead. With that, we can set up the two‑way binding. On the input element, we draw a banana in a box, then specify the ngModel directive. We bind to the component class listFilter property. We want to display the listFilter here, so we use interpolation. Recall that interpretation has no quotes. Are we done? Not quite. Let's open the terminal window. We see an error. Can't bind to ngModel since it isn't a known property of input. This is telling us that Angular can't find the ngModel directive. Recall from the slides that the ngModel directive is part of the Angular module for forms called FormsModule. To expose this directive to our ProductListComponent, we need to import the FormsModule in the module that owns the ProductListComponent, which is our AppModule. We start by importing FormsModule from angular/forms. We then add FormsModule to the imports array for the ngModule decorator. Why the imports array and not the declarations? Our directives, components, and pipes are declared here in the declarations array. Directives, components, and pipes we use from other sources, such as Angular itself or third parties, are defined in external Angular modules we add to the imports array here. Now that we've told Angular where to find the ngModel, let's see the result. When the page displays, we see cart as the default value. It is displayed here and here. If we modify the entry, notice that the displayed filter text is also updated. That's because we are using two‑way binding. Notice that the list of products is not yet filtered. We'll do that in the next module. There is one more thing we do want to address now, and that is the data formatting. That price should really look like a price and show the appropriate currency symbol.

Transforming Data with Pipes
With Angular's data binding, displaying data is easy. Just bind an element property to a class property, and we're done. Well, not always. Sometimes the data is not in a format appropriate for display. That's where pipes come in handy. Pipes transform bound properties before they are displayed, so we can alter the property values to make them more user friendly or more locale appropriate. Angular provides some built‑in pipes for formatting values, such as date, number, decimal, percent, currency, uppercase, lowercase, and so on. Angular also provides a few pipes for working with objects, such as the json pipe to display the content of an object as a JSON string, which is helpful when debugging. We can also build our own custom pipes, as we'll see in the next module. Let's start with a simple example. Say we want to display the product code in lowercase. We can add the pipe character after the property in the template expression and then specify the lowercase pipe. The product code is then transformed into lowercase before it is displayed. We can also use pipes in property bindings. Add the pipe after the property in the template expression, and specify the desired pipe. In this example, we specified the uppercase pipe, so the image title will appear in all caps. If needed, we can chain pipes. In this example, the price is transformed into a currency. By default, the currency pipe adds the all‑caps, three‑letter abbreviation of the local currency to the amount. If we want to display that abbreviation in lowercase, we can transform it again by simply adding another pipe. Some pipes support parameters. Parameters are defined by specifying a colon and the parameter value. For example, the currency pipe has three parameters, the desired currency code, a string defining how to show the currency symbol, and digit info. The digit info consists of the minimum number of integer digits, the minimum number of fractional digits, and the maximum number of fractional digits. The value here of 1.2‑2 means at least 1 digit to the left of the decimal and at least 2 digits to the right of the decimal and no more than 2 digits to the right of the decimal, effectively defining 2 decimal places. With that, let's jump back to the demo. We specify the pipes in the template, so we are looking at the product‑list.component template. Let's add a lowercase pipe for the product code and a currency pipe for the price. For the product code, we simply insert the pipe character after the property in the template expression and type lowercase. That's it. For the price, we insert a pipe character and currency. That's all that is required. But let's try out a few of the parameters. We'll specify USD, symbol to display the dollar sign instead of the currency abbreviation and 1.2‑2 to specify that we want at least 1 number to the left of the decimal place and 2 and only 2 numbers to the right of the decimal place. Let's see how he did. Ah, looking at the result, we now see the product code in lowercase and the price displayed nicely as a currency. So we can easily perform simple data transformations using the built‑in pipes in the template expressions for our bindings. Feel free to try out some of the other pipes from the slides. Let's finish up this module with some diagrams and a checklist we can use as we work with bindings and pipes.

Checklists and Summary
Data binding makes it easy to display component properties and set DOM element properties from our component to better control the view. The component can listen for and respond to events, such as a button click. And with two‑way binding, we can process user entry for an interactive experience. As we've seen, there are four basic types of binding in Angular. Here's a diagram as a memory aid. Interpolation inserts interpolated strings into the text between HTML elements or assigns element properties. Be sure to wrap the template expression in double curly braces and no quotes. Property binding sets an HTML element property to the value of a template expression. The element property must be enclosed in square brackets, and the template expression must be enclosed in quotes. Event binding listens for events from the user interface and executes a component method when the event occurs. The event name must be enclosed in parentheses, and the method to call when the event occurs must be enclosed in quotes. Two‑way binding displays a component property and updates that property when the user makes a change in an input element. Use the banana in a box syntax with the ngModel directive. The template expression must be enclosed in quotes. Here are some things to remember when using ngModel. Define ngModel within the banana in a box for two‑way binding. Be sure to add FormsModule from the Angular forms package to the imports array of an appropriate Angular module, in this case AppModule. This ensures that the ngModel directive is available to any template defined in a component associated with that module. We'll talk more about Angular modules later in this course. The data we have in our component may not be in the format we want for display. We can use a pipe in a template to transform that data to a more user‑friendly format. To use a pipe, specify the pipe character, the name of the pipe, and any pipe parameters, separated with colons. Here is an example of the currency pipe with three parameters. And here, once again, is our application architecture. In this module, we finished more of the ProductListComponent, but it could be better. Next up, we'll see several techniques for improving our component.

More on Components
Introduction
Welcome back to Angular: Getting Started, from Pluralsight. My name is Deborah Kurata, and in this module we learn several ways to approve upon our components. Components are one of the key building blocks of our application. The cleaner, stronger, and more durable we make these blocks, the better our application, so how can we make our components better? Strong typing helps minimize errors through better syntax checking and improved tooling, but what if there is no predefined type for a property? To strongly type a property that has no predefined type, we define the type ourselves using an interface. If a component needs special styles, we can encapsulate those styles within the component to ensure they don't leak out to any other component in the application. A component has a lifecycle managed by Angular. Angular provides a set of lifecycle hooks we can use to tap into key points in that lifecycle, adding flexibility and responsiveness to our application. As we saw in the last module, pipes provide a convenient way to transform bound data before displaying it in the view. We may have other application‑unique data transformation requirements. Luckily, we can build our own custom pipes. Any time we build and test a component once and nest it in several places in the application, we have minimized development time and improved the overall quality of the application. In this module, we explain interfaces and demonstrate how to use them to strongly type our objects. We look at how to encapsulate component styles, we introduce the component lifecycle and how to hook into its events, and we detail how to build a custom pipe. We cover building nested components in the next module. Looking at our application architecture, in this module we'll add features to improve the Product List component. Let's get started.

Defining Interfaces
One of the benefits of using TypeScript is its strong typing. Every property has a type, every method has a return type, and every method parameter has a type. This strong typing helps minimize errors through better syntax checking and tooling. In some cases, however, we have a property or method that does not have a predefined type, such as our products array here. We defined our products array as any, which negates the benefits of strong typing. To specify custom types, we can define an interface. An interface is a specification identifying a related set of properties and methods. Recall that properties are the data elements associated with the class, and methods perform the logic required for the class. There are two primary ways to use an interface. We use an interface to identify the properties for a specific type. In this example, we define the properties for a product. We can then specify this interface as the data type to strongly type our code. It's good practice to define an interface for any unique data types you need. The second way to use an interface is to identify a feature set. We declare the properties and methods required to implement a specific feature. Declarations only, no code. In this example, we define a timing feature with a count property and start and stop methods. To leverage this feature in a component, we specify the interface using the implements key word. We then write the code for each defined property and method. Think of this interface as an implementation pattern detailing the properties and methods we need for a specific feature. Angular provides some of its features as interfaces, and we use those features by implementing those interfaces. This concept of implementing interfaces may seem a bit daunting at first, but we'll see several examples throughout the remainder of this course. For now, let's focus on using an interface as a data type. Here is an example of a TypeScript interface. We define an interface using the interface keyword followed by the interface name, which is often the name of the thing that the interface describes. By some naming conventions, the interface is prefixed with an i for interface, though many TypeScript developers leave off this prefix. The export keyword here at the front exports this interface, thereby making it available for use anywhere in the application. The body of the interface defines the set of properties appropriate for this type. This example defines the properties for a product. For each property, the interface includes the property name, a colon, and the property data type. Once we have defined an interface, we can use it as a data type. We import the interface and then use the interface name as the data type, just like we used other data types such as string or boolean. Let's try this out. We are back in the sample application looking at the ProductListComponent. Here we see that we defined our products array as any. So let's create an interface that defines what a product is. We'll put the interface into its own file in the products folder. We'll name that file product.ts. We first type the export keyword to ensure the other parts of the application can use this interface. That is, after all, why we are creating it. Next, we type in the interface keyword, then the name of the interface. And we are defining a product, so IProduct. Inside the interface, we define the properties. For each property, we define the property name, a colon, and the type of the property. Notice that we are typing the release date as a string. If we later work with this value as a date object, we could change this type to a date. That's it. That's all we have to do to define an interface. Now we can use this interface as our data type in the ProductListComponent. Before we do though, let's try something. Let's introduce a typographical error into our products array. No error is detected. We won't even know we made a mistake until we see the application in the browser. And we notice that no image is displayed for one of the products. As you can imagine, these kinds of errors could cause hard‑to‑find bugs. Now let's replace the any with IProduct. We get a syntax error. What did we miss? Yep, we need an import. And bang, now that our array of products is strongly typed, we are notified that we made an error in our product array property. We don't even have to view it in the browser to see that something is amiss. So this is a good demonstration of one of the benefits of strong typing. Let's fix that error. Notice that we get IntelliSense now for these properties, another great benefit of strong typing. Let's check this out in the browser. Now everything works as it did. Next, let's look at encapsulating component styles.

Encapsulating Component Styles
When we build a template for a component, we sometimes need styles unique to that template. For example, if we build a sidebar navigation component, we may want special li or div element styles. When we nest a component that requires special styles within a container component, we need a way to bring in those unique styles. One option is to define those styles directly in the template's HTML, but that makes it harder to see, reuse, and maintain those styles. Another option is to define the styles in an external style sheet. That makes them easier to maintain, but that puts the burden on the container component to ensure the external style sheet is linked in the index.html. That makes our nested components somewhat more difficult to reuse. But there is a better way. To help us out with this issue, the Component decorator has properties to encapsulate styles as part of the component definition. We add unique styles directly to the component using the styles property. This property is an array, so we can add multiple styles separated by commas. A better solution is to create one or more external style sheets and identify them with the styleUrls property. This property is an array so we can add multiple style sheets separated by commas. By encapsulating the styles within the component, any defined selectors or style classes are only applicable to the component's template and won't leak out into any other part of the application. Let's try this out. Before we change any code, let's look again at our product list view in the browser. Notice the table headers. They could use a little color. So let's build an external style sheet for our ProductListComponent. We'll add a new file in the products folder. And since this file only contains the styles for our ProductListComponent, we'll call it product‑list.component.css. In this style sheet, we add a table header style. We can modify the thead element styles directly because this style sheet is encapsulated in this component, and the styles defined here won't affect any other component in the application. We could add any other styles as needed to jazz up our ProductListComponent. To use this new style sheet, we modify the ProductListComponent. In the Component decorator, we specify our unique style sheet. We add the styleUrls property and pass it an array. In the first element of the array, we specify the path to our style sheet. Since we defined the CSS file in the same folder as the component, we can use the ./ relative path syntax. We could add more style sheets here separated with commas. Let's review the result in the browser. And we see that the table header is now a nice blue color. We can use the styles or styleUrls property of the Component decorator anytime we want to encapsulate unique styles for our component. Next up, let's dive into lifecycle hooks.

Using Lifecycle Hooks
A component has a lifecycle managed by Angular. Angular creates the component, renders it, creates and renders its children, processes changes when its data‑bound properties change, and then destroys it before removing its template from the DOM. Angular provides a set of lifecycle hooks we can use to tap into this lifecycle and perform operations as needed. A lifecycle hook is an interface provided by Angular. We talked about interfaces earlier in this module. We implement a lifecycle hook interface to write code that is executed when the component's lifecycle event occurs. For example, when a component is first created and initialized, we may want to get the data for the page. So we implement the OnInit lifecycle hook and write code in that hook method to get our data. Since this is a Getting Started course, we'll limit our focus to the three most commonly used lifecycle hooks. Use the OnInit lifecycle hook to perform any component initialization after Angular has initialized the data‑bound properties. This is a good place to retrieve the data for the template from a back‑end service, as we'll see later in this course. Use the OnChanges lifecycle hook to perform any action after Angular sets data‑bound input properties. We have not yet covered input properties. We'll see those in the next module. Use the OnDestroy lifecycle hook to perform any cleanup before Angular destroys the component. To use a lifecycle hook, we implement the lifecycle hook interface. We are using the OnInit interface from Angular. So any guesses as to our next step? Yep, we need to import the lifecycle hook interface. We can then write the hook method. Each lifecycle hook interface defines one method, whose name is the interface name prefixed with ng for Angular. For example, the OnInit interface hook method is named ngOnInit. At this point in our application, we don't need to implement any lifecycle hooks, but we'll use them in later modules, so let's try them out now. We are looking at the ProductListComponent. We'll add the OnInit lifecycle hook to this component. First, we implement the interface by adding it to the class signature. Type implements and the name of the interface, OnInit. The interface name is showing an error, and we know why. We don't have the import. Let's add that now. Now we have another syntax error here. Class ProductListComponent incorrectly implements interface OnInIt. As the message states, now that we've implemented the interface, we must write code for every property and method in that interface. The OnInit interface only defines one method, ngOnInit, so we need to write the code for the ngOnInit method. We'll add it down here by the other methods. Since we don't really need to do anything with this at this point, we'll just use console.log to log a message to the console. We can view the application in the browser and use the F12 developer tools to open the console and view the logged message. We can see our message here. We'll use ngOnInit later in this course. Up next, we'll build a custom pipe.

Building Custom Pipes
As we saw in the last module, we use pipes for transforming bound properties before displaying them in a view. There are built‑in pipes that transform a single value or an iterable list of data. We covered these in the last module. In this module, we want to build our own custom pipe. For our sample application, the product code is stored with a dash and displayed that way here, but the users would prefer to see the product code with a space instead. We could build a custom pipe to replace the dashes with spaces, but let's build a more generalized custom pipe that transforms any specified character in a string to a space. The code required to build a custom pipe may look somewhat familiar at this point. It uses patterns similar to other code we've created in this course. Here is the class. We add a pipe decorator to the class to define it as a pipe. Similar to the other decorators we've used, this is a function, so we add parentheses. We pass an object to the function, specifying the name of the pipe. This is the name for the pipe used in the template as we'll see shortly. We implement a PipeTransform interface, which has one method, transform. We write code in the transform method to transform a value and return it. The first parameter of the transform method is the value we are transforming. In this example, we transform a string. Any additional parameters define arguments we can use to perform the transformation. In our case, we want to pass in the character that we want to replace with spaces. The method return type is also defined as a string because we are returning the transformed string. And, of course, we have our import to import what we need. To use a custom pipe in a template, simply add a pipe and the pipe name. Include any arguments required by the transformation separated by colons. The value being converted, our productCode here, is passed in as the first argument to the transform method. This is our pipe name. The colon identifies a pipe parameter, so our dash is passed in as the second argument to the transform method. The passed‑in value is then transformed as defined by the logic within this method, and the transformed string is returned and displayed here. But of course, that is not enough. We also need to tell Angular where to find this pipe. We add the pipe to an Angular module. How do we know which Angular module? Well, at this point, that's easy because we only have one, AppModule. But if we had multiple modules, we'd added to the module that declares the component that needs the pipe. In our example, the ProductListComponent's template needs the pipe. So we add the declaration to the same Angular module that declares the ProductListComponent. We define the pipe in the declarations array of the NgModule decorator. Now let's build our custom pipe. Since our custom pipe is somewhat general, we'll add it to the shared folder. We'll create a new file and call it convert‑to‑spaces.pipe.ts following our naming conventions. First, let's write the code for the class, export so we can import this pipe where we need it, class, and the class name. We'll call it ConvertToSpacesPipe. We decorate the class with the pipe decorator and import pipe from angular/core. We set the name property of the object passed into the pipe decorator, defining the pipe's name. That's the name we'll use when we reference the pipe in the HTML. Next, we'll implement the PipeTransform interface. This syntax error is because we don't have the import statement, so let's add that next. We still have a syntax error because when we implement the PipeTransform interface, we are required to implement every property and method defined in that interface. For the PipeTransform interface, there is only one method, transform. We'll define the string value to transform as the first parameter and the character string to use in the transformation as the second parameter. And we can add a return statement to get rid of this last syntax error. Now what we want to transform method to do? Our goal is to replace any of the specified characters in a string with spaces. We'll use the JavaScript string replace method to replace the specified character with a space. That's it. Now we are ready to use our pipe. In the product‑list template, we'll add our pipe to the productCode. But the productCode already has a pipe. That's okay. We can add any number of pipes. First, we specify the pipe name and then any pipe parameters. In this case, we want to replace a dash with a space, so we pass in a dash here as the parameter. Are we done? Recall from the slides that we need to tell Angular about our new pipe. We do that by declaring the pipe in an Angular module. Our ProductListComponent's template wants to use the convertToSpaces pipe. So we open the Angular module that declares the ProductListComponent, which, in our example, is the AppModule. We then add ConvertToSpacesPipe to the declarations and add the needed import. Now any component declared in AppModule can use the ConvertToSpacesPipe. Success! Our product code now appears with spaces instead of dashes. Build a custom pipe anytime you need to perform application‑unique data transformations. Notice, however, that our page interactivity is still not complete. The product list is not yet filtering based on the user‑entered filter criteria. Let's look at that next.

Getters and Setters
We have an input box here for the user to enter a filtered string. The list of products should then be filtered on the entered string. How do we do that? Before we answer that question, let's take a moment to talk about JavaScript getters, and setters. In JavaScript, and hence, in TypeScript, there are two ways to define a property in a class. We can declare a simple variable for a property, as we've done previously in this course. Metaphorically, think of this simple variable property as a piggybank. We can put money directly into the piggybank or take money out of the piggybank. Another way to define a property is with a JavaScript getter and setter. Think of a getter and setter as a bank. We set money into our account, the bank processes the amount, and holds the money in a private vault somewhere. When we want to get that amount, the bank needs to get the money from private storage before it can return that amount. When creating a getter and setter, we often define a private storage variable called a backing variable to store the value managed by the getter and setter. We use the private keyword to denote that this backing variable is private and should only be managed by the getter and setter. To help us recognize this variable as private, by convention, we prefix it with an underscore. In the getter, we return the amount from private storage, optionally processing that amount before returning it. For example, we could convert the value to another currency or format the value. In the setter, we set the amount in private storage, optionally processing that amount. For example, we could log the amount or update the total balance. The bottom line here is by using a getter and setter instead of a simple variable for a property, we can write code to process the value when its get or set. We access these properties just like simple variable properties, using this to reference the class and then the property name. The code here sets 200 into the amount, and this code gets the amount and logs it to the console. What does that mean for us and our filter string? If we use a getter and setter for the list filter, we can write code that filters the list of products every time the filter string is set. So as the first step in implementing the list filtering, let's change our list filter property to a getter and setter. Here in our product‑list.component is our listFilter property assigned to our default value. We want to execute code when this property is set. Let's delete this simple variable and instead build a getter and setter. First, we declare our private backing variable to hold the value managed by the getter and setter. We use an underscore in front of the property name to denote it as a private variable and initialize it to an empty string. Next, we define the getter. A getter begins with the get keyword, followed by the name of the property in parentheses, and we specify the property data type. The body of the getter can include code to process the property value before returning it. The getter then returns the processed value. Since we don't need to process the listFilter on a get, we'll return the value of the backing variable. The setter begins with the set keyword, followed by the name of the property. The setter has a single parameter, which is the value assigned to the property. The setter has no return value. The setter is executed any time a value is assigned to the associated property, so we can use the body of the setter to perform an operation when the property is changed such as filtering our list of products. Minimally, we set the value into our private backing variable. We'll add the code to filter the list in the next clip. For now, let's just log the value. Recall that our original simple variable property was assigned a default value. Where do we set a default now? Let's use the ngOnInit method we defined earlier. Here, we set our listFilter property to cart. Checking it out in the browser and opening the developer tools, we see that the setter is initially assigned to our default value of cart. If we delete the filter, the setter displays an empty value. Type am, and we see that the setter first sets the a, then the am. Every time the user types, the value is set, and the setter is executed, passing in the value from the text box. Use a getter and setter any time you want to execute code when a property is get or set. Now let's see how to use this knowledge to filter our list of products.

Filtering and Arrow Functions
We are working toward our goal of using the entered filter string here to filter our list of products. Our product list is defined as an array, so we can use JavaScript array methods to work with our list of products. To filter our array, we use the JavaScript filter method. The filter method creates a new array. The filter, then evaluates each product in the original array to determine whether to include it in the new array. The filter method, then returns the new array, containing only the filtered products. Somehow, we need to tell the filter method the logic we want for determining whether a product meets our filter criteria. The filter method expects our logic to return true if the product should be in the filtered list, otherwise return false. We define that logic with an arrow function. An arrow function is compact syntax for defining a function. Think of it as a shorter way to define a classic named function. It's most often used when passing logic to another function or method. Here is a classic named function that capitalizes the product name and returns it. To write this code as an arrow function, we ignore the function name, as arrow functions don't need a name to find the parameters, then an arrow. This is what gives an arrow function its name. We ignore the curly braces and return keyword. Arrow functions with a single statement have an implied body and return. Then we write the required logic. If the arrow function requires multiple statements in the function body, then we do need to use curly braces and the return keyword. Use an arrow function any time you need to pass a function into another function or method. We'll see more arrow functions later in this course. To specify the logic to filter our products, we pass an arrow function into the filter method. We first list the parameters to the arrow function. In this example, the filter method iterates through each product in the array, passing each product into the arrow function. So we have only one parameter, a product. We then use an arrow to separate the parameter list from the function body. A requirement is that the filtered list should only contain products with a product name that includes the listFilter. This includes method returns true if the defined string is found in the product name, otherwise it returns false. Now let's jump back into the demo. Here is our product‑list.component. Let's think through what we need to do. First, we need a filtered list of products that we can bind to. We can define a property for that here. Why don't we just filter our products array? Because once we filter the products array, we lose our original data and can't get it back without regetting the data from its source. Next, we want to filter our products every time the list filter changes. Where do we write that code? If you said the properties setter, you are right. In the listFilter setter, we set our filteredProducts property to our filtered list of products. Let's define a method to filter our products. We'll call it performFilter and pass it the listFilter value. Now let's write the performFilter method. We'll add it down here by the other methods. The performFilter method takes in the listFilter, which is a string. The method returns the filtered array of products. This code starts by converting the filter criteria to lowercase. Why? So we can compare apples to apples when we filter the product list. We want a case‑insensitive comparison. Then we return the filtered list of products. We start with the original full list of products, which is an array, so we can use any of the JavaScript array methods. We want to use filter. We pass into the filter method an arrow function that processes each passed‑in product. In the body of the arrow function, we check the productName. Since we lowercased the listFilter string, we'll lowercase the productName as well to ensure we perform a case‑insensitive check. We then call the string includes method, passing in the filter string. The includes method returns true if the productName includes the defined filter string. So this code filters our list of products to only those with a product name that includes the list filter string. If the list filter string is empty, it returns all products. There is one more step. We need to change our template to bind to our filteredProducts property instead of our products property. Let's give it a try. Our default filter is cart, so now we only see the Garden Cart. Change the filter, and we see different entries. It's working. Not too shabby, not too shabby at all. Let's finish up this module with some checklists we can use as we work more with components.

Checklists and Summary
To ensure all variables are typed, we define an interface for any custom types. When creating an interface, use the interface keyword. In the body of the interface, define the appropriate properties along with their types. And don't forget to export the interface so it can be used anywhere in our application. Then use the interface as a data type, just like any other data type such as string or number. Interfaces can also be used to declare the properties and methods for a feature. Though we may not need to define this kind of interface ourselves, we often implement provided interfaces, including built‑in Angular interfaces. Implementing an interface for a feature ensures that our class defines every property and method required for that feature. Add the implements keyword and the interface name to the class signature. Then be sure to write code for every property and method declared in the interface to fully implement the feature. We can encapsulate the styles for our component in the component itself. That way, the styles required for the component are associated with the component alone and don't leak into any other parts of the application. Use the styles property of the @Component decorator to specify the template styles as an array of strings. Use the styleUrls property of the component decorator to identify an array of external stylesheet paths. The specified styles are then encapsulated in the component. Lifecycle hooks allow us to tap into a component's lifecycle to perform operations. The steps for using a lifecycle hook are: Import the lifecycle hook interface, implement the lifecycle hook interface in the Component class, then write the code for the hook method defined in the lifecycle hook interface. To build a custom pipe, create a class that implements the PipeTransform interface. This interface has one method‑‑Transform. Be sure to export the class so the pipe can be imported from other components. Write code in the Transform method to perform the needed transformation, and decorate the class with the @Pipe decorator. We can use a custom pipe in any template anywhere we can specify a pipe. In an Angular module, metadata declare the pipe in the declarations array. Then any template associated with a component declared in that Angular module can use that pipe. In a template, immediately after the property to transform, type a pipe character, specify the pipe name, and enter the pipe arguments, if any, separated by colons. So in this module, we've completed the Product List Component (yay). Next up, we'll see how to build nested components and build this Star Component.

Building Nested Components
Introduction
Our user interface design may include features that are complex enough to be separate components or that are reusable across our views. Welcome back to Angular: Getting Started from Pluralsight. My name is Deborah Kurata, and in this module, we see how to build components designed to be nested within other components, and we'll discover how to establish communication between the nested component and its container component. Just like nesting dolls, we can nest our components. We can nest a component within another component and nest that component within yet another component and so on. And because each component is fully encapsulated, we expose specific inputs and outputs for communication between a nested component and its container, allowing them to pass data back and forth. There are two ways to use a component and display the component's template. We can use a component as a directive. Recall that a directive is custom syntax we use to power up our HTML. When using a component as a directive, we use the component selector as a custom HTML tag. We saw how to use a component as a directive when we displayed the AppComponent template in the index.html file. The pm‑root directive is defined as the AppComponent selector. The template is then displayed within the directive tags. We use the same technique with nested components. Alternatively, we can use a component as a routing target, so it appears to the user that they've traveled to another view. The template is then displayed in a full page‑style view. We'll use this technique later in this course to route to our product list view. Our product list view is currently used as a directive, but that's only because we have not yet covered routing. In this course module, we'll focus on building a nested component. So what makes a component nestable? Technically speaking, any of our components could be nested if they have a selector defined in the Component decorator. But does it really make sense to nest a large view, such as our product list? For our purposes, we'll define a component as nestable if its template only manages a fragment of a larger view, if it has a selector so it can be used as a directive, and, optionally, if it communicates with its container. In this module, we'll build a nested component. Then, we'll review how to use that nested component as a directive in a container component. We'll examine how to pass data to the nested component using a property with the Input decorator and how to pass data out of the nested component by raising an event defined with the Output decorator. In our sample application, to improve the user experience, we want to replace the rating number displayed in the ProductListComponent with stars. In this module, we'll build the StarComponent and nest it within the ProductListComponent. Let's get started.

Building a Nested Component
Here is a visual representation of a component that is nestable. Here is another component. It wants to use the nestable component in its template. We then refer to the outer component as the container or parent component, and we refer to the inner component as the nested or child component. In our sample application, we want to change the display of the five‑star rating from this to this. Displaying the rating number using a visual representation, such as stars, makes it quicker and easier for the user to interpret the meaning of the number. This is the nested component we'll build in this module. Let's jump right in and build our StarComponent. When we last saw our sample application, we had completed the ProductListComponent. Now, of course, we want to change it. Instead of displaying a number for the rating here, we want to display stars. Instead of adding the code to the ProductListComponent to display the stars, we want to build it as a separate component. This keeps the template and logic for that feature encapsulated and makes it reusable. So let's begin by creating a StarComponent. The StarComponent can be used by any feature of the application, so it really doesn't belong in our products folder. We'll instead put it in a shared folder, where we'll put all our shared components. If you are using the starter files, I've already created this folder and included the template and style sheet for our component here. Let's take a quick look at the style sheet. Notice that we have a style here that helps with cropping our stars. Now we are ready to build the StarComponent. We begin by creating a new file. We'll name it star.component.ts. We then create this component just like we'd create any other component, starting with the class, export class StarComponent. What's next? Yep, we decorate the class with the Component decorator. Recall that it is this Component decorator that makes this class a component. As always, it shows us a syntax error here because we are missing, yep, our import. Time to set the Component decorator properties. For the selector, we'll set pm‑star. For the templateUrl, we provide the path to the HTML file provided with the starter files. We'll add the styleUrls property, and in the array, we'll set the first element to the path of the style sheet that was also provided. Since both files are in the same folder as the component, we can use relative pathing. Let's take a peek at the StarComponent template. Here it displays five stars using the Font Awesome star icon from the style sheets we imported earlier in this course. The div element sets the size for displaying the 5 stars to 75 px. The outer div element then crops the 75 px based on a defined cropWidth. This technique can then display partial stars, such as 4.5 of the 5 stars, by setting the cropWidth such that only 4.5 of the stars appear. Recall what this syntax is called? This is property binding. We are using it here to bind the title property to display the numeric rating value. For these bindings to work, we need two properties in the component class, the rating number and the cropWidth. Going back to the StarComponent, we'll add the two properties. We want a rating property, which is a number and defines the actual rating value. Since we don't yet have a way to get this value from the container, let's hard code it to 4 for now so we'll see some stars. And we need the cropWidth. We'll default it to 75, which is the width of our 5 stars as defined in the template. This value is then recalculated based on the rating. Where do we put that calculation? Well we'd want the cropWidth recalculated anytime the container changes the rating number. So let's tap in to the OnChanges lifecycle hook as we discussed in the last module. We'll implement the OnChanges interface, import OnChanges, and write code for the ngOnChanges method identified in the OnChanges interface. In this method, we'll assign the cropWidth using the rating. The total size of the 5 stars is 75 px. So each star is approximately 75 divided by 5 px. We multiply that by the rating number to get the cropWidth. For example, if the rating is 4, 4 times 75 divided by 5 is 60 pixels. So we'd crop the 75‑px display of stars to 60 px, effectively only showing 4 of the stars. Our component is complete, and we are ready to nest it in another component. Let's do that next.

Using a Nested Component
We are ready to nest our new component within another component. Here is a shortened form of the code for a container component and its template, and here is the nested component we just created. Instead of displaying the starRating number, we want to display the stars, so we nest the StarComponent in the product‑list.component using the star component's selector as a custom HTML tag. This identifies where in the container to place the nested component's template. With the custom HTML tag in place, we are now using the nested component as a directive. As we've seen in prior demos, when we use the component as a directive, we need to tell Angular how to find that directive. We do that by declaring the nested component in an Angular module. How do we know which Angular module? Well, we still only have one Angular module, AppModule. In our example, the ProductList component's template wants to use the StarComponent, so we add the declaration to the same Angular module that declares the ProductList component. We define the nested component in the declarations array of the @NgModule decorator and, as always, define what we need by adding an import statement. Let's jump right back to our demo. Our star.component is now shown here on the right. We want to use our star.component in the ProductList template that is here on the left. In the table data element, we want to replace the display of the starRating number with our StarComponent. To do that, we simply replace the binding with our directive. Now our ProductList template will display our stars here. Next we need to tell Angular where to find this directive. Since we only have one Angular module, we'll add the declaration for the nested component there. Add the StarComponent to the declarations array passed into the @NgModule decorator. These are the same steps we followed earlier in this course to use a component as a directive. Nothing new here so far. Let's see what we did. We have stars, yes! Hmm, but we see five of them. Let's clear out the filter. Yes, we see five every time. Hover over the stars, and we see are hardcoded star rating is four. It seems that our cropWidth is not being calculated Let's look at the code again. We set the cropWidth property in the ngOnChanges method when the OnChanges lifecycle event occurs. But the OnChanges lifecycle event never occurs, because OnChanges only watches for changes to input properties. We don't have any input properties, so we have two problems. Our OnChanges event doesn't fire, and we don't currently have a way to get the correct rating from the container. Let's see how input properties can solve both of these issues.

Passing Data to a Nested Component Using @Input
When building an interactive application, the nested component often needs to communicate with its container. The nested component receives information from its container using input properties. For the StarComponent to display the correct number of stars, the container must pass in the product's rating as an input to our StarComponent. The nested component outputs information back to its container by emitting events. In our example, if the user clicks on the stars, we want to emit an event to notify the container. Let's focus on input properties first. If a nested component wants to receive input from its container, it must identify a property for that purpose using the aptly named @Input decorator, we use the @Input decorator to decorate any property in the nested components class. This works with any property type, including an object. In this example, we want the rating passed into the nested component, so we mark that property with the @Input decorator. The container template then passes data to the nested component using property binding. Recall how to use property binding? We enclose the nested components property in square brackets and assign it to an expression enclosed in quotes. In this example, the product‑list template uses property binding to pass the product's starRating to the StarComponent. The container component can only bind to a nested component property marked with the @Input decorator. So in this example, the product‑list template combined to the rating but not the cropWidth. Let's give this a try. Here are the StarComponent and the product‑list template. The StarComponent wants its container to pass in the rating. As we saw in the slides, we add the @Input decorator to any property we want passed in. It's a decorator, so we specify the @ sign. The @Input decorator is a function, so we add parentheses and add the associated import. We don't need to pass anything to this function, so that's it. And let's reset the default to 0. In our example, we decorated only one property of the nested component with the @Input decorator, but we are not limited to one. We can expose multiple input properties as needed. In the container's template, we bind the nested components input property using property binding with square brackets. Then we set the binding to the value we want to pass in to the nested component. In this example, we want to pass the product's starRating. That's it. The product.starRating is now bound to the rating input property of the nested component. Any time the container data changes, the OnChanges lifecycle event is generated, the cropWidth is recalculated, and the appropriate stars are displayed. Let's check it out in the browser. That looks better. But what if we want to send data back from our nested component to our container? Let's look at that next.

Handling Events
Before we dive in to passing events from a nested component to its container, let's take a moment and review how to handle events within a component. In this demo, we'll handle a click event on the stars. Here is the star.component on the right and its template on the left. We want to do something every time the user clicks on the stars. Recall how to set up event binding? Let's add click event binding to the outer div element here in the template. We'll define event binding by specifying the event within parentheses. We bind it to a method in the component that we'll call onClick. Next, we write the onClick method in the component. The method has no return type, so we specify void. For now, let's log a message to the console every time the user clicks on the stars. Here, I'm using ES2015 backticks to specify a JavaScript template literal. A template literal allows us to use a placeholder to insert an expression within a string. In this expression, we display the product rating. Bring up the browser and open the developer tools. Then let's clear the default Filter by so we have more products. Click on a product, and we see the star rating logged to the console. Click another product, and we see its star rating. Our nested component can now react when the user clicks on a rating, but what if we want to pass that event to the container component?

Passing Data from a Component Using @Output
We saw how the container passes data to the nested component by binding to a Nested Component property decorated with the Input decorator. If the nested component wants to send data back out to its container, it can emit an event. The nested component must identify a property for that purpose using the aptly named Output decorator. We can use the Output decorator to decorate any property of the Nested Components class, however, the property must be an event. The only way a nested component can pass data back to its container is by emitting an event. In Angular, an event is defined with an EventEmitter object. So here, we create a new instance of an EventEmitter. Notice the syntax here. TypeScript supports generics. If you are not familiar with generics, this syntax allows us to identify a specific type that the object will work with. When creating an EventEmitter, the generic argument identifies the type of data that is passed with the event. If we want to pass a string value to the container in the event, we define string here. If we wanted to pass multiple values, we can specify an object here. In this example, we define a notify event with string data. When the user clicks on the stars, only the StarComponent receives that click event. Instead of processing the click event itself, the star.component can emit a new event to its container and optionally pass along some data. In this example, the onClick method emits the notify event and passes along a string message. In the container components template, we used event binding to bind to the StarComponent's notify event, then call a method in the container component when that event occurs. We access the event data using $event. Since the event data is a string, this method takes in a string. Let's give this a try. What is our goal? When the user clicks on one of the star ratings, we want to display that rating in the product list component header. This feature may not be incredibly useful, but it demonstrates how to pass events from our nested child component to the parent container component. In the last clip, we added event binding to the nested component. When the user clicks on the stars, it logs a message. We instead want to send an event to the container component with that string message. We are back in the sample application, looking at the star.component, product‑list component, and product‑list template. Recall from the slides how the nested component sends data out to its container, it uses an event with the Output decorator. Let's define a ratingClicked event property in the nested component. Since this must be an event, we define the type of this property to be event emitter. Use the provided quick fix to add event emitter to the import statement. We want to pass a string to the container as part of this event, so we specify string as the generic argument. We then set the ratingClicked property to a new instance of EventEmitter. This defines our new event. We use the @ sign to decorate the event property and then specify the Output decorator so the container can respond to this event. The Output decorator is a function, so we add parentheses. We, again, use the quick fix to add output to the import statement. In this example, we are decorating only one property of the nested component with the Output decorator. but we aren't limited to one. We can expose multiple output properties as needed. Here in our star components onClick method, instead of logging this message, we want to emit our ratingClicked event and pass the message to the container component. We use the event property and call its emit method passing in the desired string. Now that we are emitting this ratingClicked event to our container, how does the container listen for and respond to the event? It uses event binding. In the product‑list.component template, we bind to the event emitted from the StarComponent using event binding. For event binding, we use parentheses and specify the name of the event to listen for. We want to listen for the StarComponent's ratingClicked event. When the event occurs, we call a method in the product‑list.component. Let's call it onRatingClicked. Recall that we are passing a string when raising this event, so let's pass that string into our onRatingClicked method. We do that using $event, $event passes along any data associated with a generated event. Next, we need to write the code for this method in the product‑list.component class. Our template is expecting that we have a method called onRatingClicked and is passing a string message with the event. Our method returns no value, so we define the return type as void. Now that we have the message from the event, what do we want to do with it? Our goal was to display it on the page title, so we'll modify the pageTitle to display Product List and the message from the nested StarComponent. Okay, yeah, that is not a very real world example, but I wanted to keep this as straightforward as possible. Let's see how this works in the browser. Click on the star rating, and we see the page title changed to display the message received from the nested component. Success! Let's finish up this module with some checklists we can use as we build nestable components.

Checklists and Summary
We just saw how the container passes data to the nested component by binding to a nested component property that is decorated with the @Input decorator and how the nested component uses an event property decorated with the @Output decorator to raise events. We can think of the properties decorated with the @Input or @Output decorators as the public API of the nestable component. Everything else in the component is encapsulated and only accessible to the component's template and class. Decorate a nested component property with the @Input decorator anytime it needs input data from its container. Any type of component property can be decorated with the @Input decorator. Don't forget the @ prefix, and since the @Input decorator is a function, follow it with open and closing parentheses. Decorate a nested component property with the @Output decorator anytime it needs to emit events and optionally pass data to its container. Only properties of type EventEmitter should be marked with the @Output decorator. Use the EventEmitter's generic argument to specify the type of the event data, and use the new keyword to create a new event. Don't forget the @ prefix, and since the @Output decorator is a function, suffix it with open and closing parentheses. In the container component's template, use the nested component as a directive. For the name of the directive, use the nested component's selector. Use property binding to pass data to the nested component. Use event binding to respond to events from the nested component, and use $event to access the event data passed from the nested component. To learn more about nested or child components, check out the Angular Component Communication course here in the Pluralsight library. In this module, we built the Star component and nested it within the Product List component. We can reuse this component in any other component of the application, such as the Product Detail component. Next up, let's check out how to build an Angular service so we won't need hard‑coded product data in our component.

Services and Dependency Injection
Introduction
Components are great and all, but what do we do with data or logic that is not associated with a specific view, or that we want to share across components? We build services. Welcome back to Angular: Getting Started, from Pluralsight. Deborah Kurata here, at your service, and in this module, we create a service and use dependency injection to inject that service into any component that needs it. Applications often require services such as a product data service or a logging service. Our components depend on these services to do the heavy lifting. Wouldn't it be nice if Angular could serve us up those services on a platter? Well, yes, it can, but what are services exactly? A service is a class with a focused purpose. We often create a service to implement functionality that is independent from any particular component, to share data or logic across components, or encapsulate external interactions such as data access. By shifting these responsibilities from the component to a service, the code is easier to test, debug, and reuse. In this module, we start with an overview of how services and dependency injection work in Angular. Then we'll build a service, we'll register that service, and we'll examine how to use the service in a component. We currently have several pieces of our application in place, but we hard‑coded our data directly in the product list component. In this module, we'll shift the responsibility for providing the product data to a product data service. Let's get started.

How Does It Work?
Before we jump into building a service, let's take a look at how services and dependency injection work in Angular. In this diagram, our service is here, and our component that needs the service is here. There are two ways our component can work with this service. The component can create an instance of the service class and use it. That's simple, and it works. But the instance is local to the component, so we can't share data or other resources. And it will be more difficult to mock the service for testing. That's why we don't normally use this technique when working with services. Alternatively, we can register the service with Angular. Angular then creates a single instance of the service class, called a singleton, and holds onto it. Specifically, Angular provides a built‑in injector. We register our services with the Angular injector, which maintains a container of created service instances. The injector creates and manages the single instance, or singleton, of each registered service as required. In this example, the Angular injector is managing instances of three different services, log, math, and myService, which is abbreviated svc. If our component needs a service, the component class defines the service as a dependency. The Angular injector then provides, or injects, the service class instance when the component class is instantiated. This process is called dependency injection. Since Angular manages the single instance, any data or logic in that instance is shared by all of the classes that use it. This technique is the recommended way to use services because it provides better management of service instances, it allows sharing of data and other resources, and it's easier to mock the services for testing purposes. Now let's look at a more formal definition of dependency injection. Dependency injection is a coding pattern in which a class receives the instances of objects it needs, called its dependencies, from an external source rather than creating them itself. In Angular, this external source is the Angular injector. Now that we've got a general idea of how services and dependency injection work in Angular, let's build a service.

Building a Service
Are we ready to build a service? Here are the steps. Create the service class, define the metadata with a decorator, and import what we need. Look familiar? These are the same basic steps we followed to build our components and our custom pipe. Let's look at the code for a simple service. Here is the class. We export it so the service can be used from any other parts of the application. This class currently has one method, getProducts. This method returns an array of products. Next we add a decorator for the service metadata. When building services, we use the Injectable decorator. Lastly, we import what we need, in this case Injectable. Now let's build our service. Since our service will only provide product data, we'll add it to the products folder. We'll create a new file and call it product.service.ts to follow our naming conventions. We're then ready to create the service class. I bet you can do it in your sleep by now, export class and the class name. Since this service provides products, we'll call it ProductService. Next, we decorate the class with the Injectable decorator, and we'll add the import statement for that decorator. Now that we have the structure in place, we can add properties or methods to the class as needed. Unless marked private or protected, the properties and methods defined in the class are accessible to any class that uses this service. For our ProductService, we want a getProducts method that returns the list of products. We strongly typed this return value using our IProduct interface. So we need to import this interface. In the next module, we'll see how to retrieve the products using HTTP. For now, we'll hard code them in here. If you're coding along, feel free to copy some products from the products.json file in the api/products folder. Notice that we have no properties defined in this class. So we are not using this particular service to share data. We are using it to encapsulate the data access features. By using the service to provide the list of products, we take the responsibility for managing the data away from the individual component. That makes it easier to modify or reuse this logic. A service is just really an ordinary class until we register it with an Angular injector. Let's do that next.

Registering the Service
As we illustrated in this diagram, we register the service with the Angular injector, and the injector provides the service instance to any component that injects it using the constructor. The injector represented here is the root application injector. But wait, there's more. In addition to the root application injector, Angular has an injector for each component, mirroring the component tree. A service registered with the root application injector is available to any component or other service in the application. A service registered with a specific component is only available to that component and its child or nested components. For example, if a service is registered with the ProductListComponent's injector, the service is only available for injection in the ProductListComponent and its child, the star component. Note that a service does not need to be defined in an Angular module. So when should you register your service with the root injector versus a component injector? Registering a service with the root injector ensures that the service is available throughout the application. In most scenarios, you'll register the service with the root injector. If you register a service with the component injector, the service is only available to that component and its child or nested components. This isolates a service that is used by only one component and its children, and it provides multiple instances of the service for multiple instances of the component. For example, we have multiple instances of the star component on the product list page, one for each row. If we had a service that tracks some settings for each star component instance, we would want multiple instances of the service, one for each instance of the component. But this is not a common scenario. With that, the next question is how? How do we register a service? That depends on which injector we use. We register the service with the root application injector in the service. We pass an object into the Injectable decorator and set the providedIn property to root. We can then access the service from any component or other service in the application. We want to use our ProductService in several components, so we'll register it with the root application injector. Let's do that now. Here in the service, we add the providedIn property to the Injectable decorator and set it to root. An instance of the ProductService is then available for injection anywhere in the application. But what if we only wanted to access the service from one component instead? For most scenarios, we'll register our service in this service using the providedIn property. The service is then available to the entire application. To register our service for a specific component, such as the ProductListComponent, we register the service in that component like this. The service is then available to the component and its child components. Note that the providedIn feature is new in Angular version 6. In older code, you'll see the service registered in a module like this. This syntax is still valid. However, the recommended practice is to use the new providedIn feature in the service instead. This provides better tree shaking. Tree shaking is a process whereby the Angular compiler shakes out unused code for smaller deployed bundles. We'll talk more about tree shaking later in this course. Now that we have registered the service, let's see how to inject the service so we can use it.

Injecting the Service
Here, again, is our diagram. In the last clip, we saw how to register the service with an Angular injector. Now we just need to define it as a dependency, so the injector will provide the instance in the classes that need it. So, how do we do dependency injection in Angular? Well, the better question is, how do we do dependency injection in TypeScript? The answer is in the constructor. Every class has a constructor that is executed when an instance of the class is created. If there is no explicit constructor defined for the class, an implicit constructor is used. But if we want to inject dependencies such as an instance of a service, we need an explicit constructor. In TypeScript, a constructor is defined with a constructor function. What type of code normally goes into the constructor function? As little as possible. Since the constructor function is executed when the component is created, it is primarily used for initialization and not for code that has side effects or takes time to execute. We identify our dependencies by specifying them as parameters to the constructor function like this. Here, we define a private variable to hold the injected service instance. We create another variable as the constructor parameter. When this class is constructed, the Angular injector sets this parameter to the injected instance of the requested service. We then assign the injected service instance to our local variable. We can then use this variable anywhere in our class to access service properties or methods. This is such a common pattern that TypeScript defined a shorthand syntax for all of this code. We simply add the accessor keyword, such as private here, to the constructor parameter. Then, this is a shortcut for declaring this variable, defining a parameter, and setting the variable to the parameter. Neat! You'll see this technique used throughout the Angular documentation and other code examples. Ready to give it a try? We want to use our service to get products in the product‑list.component. So we'll define our product service as a dependency in the product‑list.component. All we need is a constructor. We'll use the shorthand syntax to define the dependency, private productService. Then, because we are using TypeScript, we type colon and the type, which is ProductService. Note that the accessor doesn't have to be private. The shorthand syntax works with public and protected as well. So, now we have a syntax error here. I bet you know why. Yep, we need to import ProductService so we can use it as the data type here. Now, when an instance of the product‑list.component is created, the Angular injector injects in the instance of the ProductService. We are at the point now where we can actually use the ProductService. First, let's delete the hard‑coded products from here. We'll, instead get them from the service. Now the question is, where should we put the code to call the service? One thought might be to put it in the constructor, but ultimately our ProductService will go out to a back‑end server to get the data. We don't want all of that executed in the constructor. Other thoughts? Remember our discussion about lifecycle hooks? Earlier in this course, we said that the OnInit lifecycle hook provides a place to perform any component initialization, and it's a great place to retrieve the data for the template. Let's use the OnInit lifecycle hook. We want to set the products property to the products returned from our service. To call the service, we use our private variable containing the injected service instance, we then type a dot and the name of the method we want to call. Notice how IntelliSense helps us with all of this. There is a small problem with our code at this point. We aren't binding to the products property. We are binding to the filteredProducts property, and the filteredProducts property isn't set until a filter by string is entered. So when the application is initialized, let's set the filteredProducts property to our full list of products. Let's make one more little change. Let's remove the default listFilter value, so we'll see all of the products in the list. We should be all set to see our result in the browser, and here are our products. Yeah! Notice that we have more products displayed now because I hard coded more products into the service. Trying out our filtering, it still works as well. Let's finish up this module with some checklists we can use as we build our services.

Checklists and Summary
We build a service using the same techniques as when we build components and custom pipes. We start by creating the service class. We specify a clear class name appropriate for the services it provides, use PascalCasing where each word of the name is capitalized, append Service to the name, and don't forget the export keyword. We then decorate the service class with the injectable decorator. Don't forget the at prefix. And since the decorator is a function, follow it with open and closing parentheses. And be sure to define the appropriate imports. The first step to registering a service is to select the appropriate level in the injector hierarchy that the service should be registered. Use the root application injector if the service is shared throughout the application. If only one component and its children needs the service, register it with that component's injector. Pick one or the other, not both. Register a service with the root injector using the injectable decorator of the service. Set the providedIn property to root. Register a service for a specific component and its children using its component decorator. Use the providers property to register the service. In any class that needs the service, specify the service as a dependency. Use a constructor parameter to define the dependency. The Angular injector will inject an instance of the service when the component is instantiated. In this module, we built the product data service, so our product list component no longer has hard coded products. Next up, we'll see how to modify the service to retrieve data using HTTP.

Retrieving Data Using HTTP
Introduction
The data for our application is on a server somewhere, in the cloud, at the office, under our desk. How do we get that data into our view? Welcome back to Angular: Getting started, from Pluralsight. My name is Deborah Kurata, and in this module we learn how to use HTTP with observables to retrieve data. Most Angular applications obtain data using HTTP. The application issues an HTTP GET request to a web service. That web service retrieves the data, often using a database, and returns it to the application in an HTTP response. The application then processes that data. In this module, we begin with an introduction to observables and the reactive extensions. We then examine how to send an HTTP request and map the result to an array. We add some exception handling, and we look at how to subscribe to observables to get the data for our view. We finished the first cut of a product data service in the last module, but it still has hard coded data. Now, we'll replace that hard coded data with HTTP calls. Let's get started.

Observables and Reactive Extensions
To really understand the HTTP code we're about to write in this module, it's important to understand the basics of Reactive Extensions and Observables. So let's get technical for just a moment, and then we'll break down what all of this means. Reactive Extensions for JavaScript, or RxJS, is a library for composing data using Observable sequences, and transforming that data using a set of operators. If you are familiar with .NET, these are similar to LINQ operators. Angular uses Reactive Extensions for working with data, especially asynchronous data such as HTTP requests, which is why we're covering it here. So what does all of this mean? Let's start with asynchronous, then cover Observable sequences, and operators. Synchronous communication is like a phone call. It's real‑time. You talk, I immediately process the information, and respond. With synchronous data, the application requests a value and waits for it to arrive, like calling our getProducts method to get the list of products. Asynchronous communication doesn't expect an immediate response. When I send an email, I don't have to wait for a reply. I can do something else. When I am notified of a reply sometime later, I can decide when to process it. From our applications point of view, HTTP requests are asynchronous. Here is an application and here is a back‑end web server. The application wants to display products, so we send a request to the web server, asking for the product data. We then set up to be notified when the data is returned, and continue along. At some later point in time, HTTP returns a response with the requested products, and our application notifies us that the products were returned. So this process of request and response is asynchronous. We submit a request, don't wait for it, and sometime later, receive a response. In Angular, we issue the get request using HTTP, but what do we use to set up the notifications? That's where RxJS Observable sequences come in. An Observable sequence, sometimes called an Observable stream, or just an Observable, is a collection of items over time. So it's a collection, but unlike an array, it doesn't retain items. Rather, the emitted items can be observed over time. For example, here is an array of letters. We can transverse through the letters, sort the letters, or ask for the third letter. An Observable is more like this, letters arriving over time. We can't loop through them, sort them, or ask for the third letter after it's already been emitted. Think of these letters as mouse moves, or button clicks, or the user typing characters. The moves or clicks or key presses occur over time. What does an Observable do? An Observable doesn't do anything until we subscribe. Think of a subscription like a streaming service. Until you subscribe, you won't get the latest Star Trek series. When we subscribe, the Observable begins emitting notifications. There are three types of notifications. The most common is the next notification, which occurs when the next item is emitted, and it provides the emitted item. For example, think of tracking key presses. Each time a key is pressed, the Observable emits a next notification, and provides the pressed character. If an error occurs, the Observable emits an error notification, and provides the error information. The Observable then completes, and no more items are emitted. If there are no more items to emit, the Observable emits a complete notification. So that's it. Once subscribed, an Observable emits next error, or complete notifications. With that knowledge, let's revisit our prior slide with a bit more detail. To get product data for display, the code calls http get. Http get returns an Observable, which will emit notifications, so we'll know when the response arrives. We then subscribe to start the Observable, and the get request is sent. Recall that Observables don't do anything until we subscribe. The code doesn't wait for the response; it just continues along. At some later point in time, the back‑end server returns a response. The Observable emits a next notification, letting us know we have the data. We can then process the emitted response. Note that when using http get, the Observable emits the entire response as one emitted item. So if we ask for products, the HTTP response includes the products, and the Observable emits a single next notification with an array of those products. There is one more thing we can do with an Observable. We can specify a pipeline of sorts, using a set of operators to transform each emitted item. In this example, when a letter is emitted, we pipe it through a fictitious lowercase operator to change its case. We then pipe it through a fictitious enlarge operator to increase its size. Observables have over 100 not fictitious, built‑in operators to map, filter, combine, and transform data. We've covered a lot of information, some of which may feel a bit nebulous, so let's examine how to use an Observable in an Angular application, and walk through a code example.

Using an Observable
A common way to use observables in an Angular application is to first start the observable with a subscribe, then pipe each emitted item through a set of operators to modify or transform the item, then we process the notifications from the observable. Recall the three notifications that an observable emits, next, error, and complete. And lastly, we stop the observable by unsubscribing. Here is some sample code to help solidify these concepts. RxJS has two primary packages we use to import functionality. Observable and methods we can use to create observables can be found in the RxJS package. We import the operators from RxJS operators. We use the observable creation function called range to create an observable that emits 10 numbers, starting from 0, so we'll have some data to work with. We use the generic argument here to define the type of data that this observable will emit. By convention, we add a $ suffix to variables that reference an observable. This makes it easier to quickly distinguish the observables. We use the pipe method to pipe the emitted items through several operators, in this example, map and filter. We only include two operators here, but we can define any number of operators separated by commas. The map operator allows us to transform each emitted item. We define the logic for the transformation using an arrow function. The arrow function parameter is the emitted item. In this example, each emitted number is multiplied by 3 and then passed on to the following operator. The filter operator decides which items to pass on and which to filter out. We define the logic for the filtering. Yep, you guessed it, using an arrow function. The parameter to the arrow function is the item emitted from the prior operator. In this example, we filter the result to only the even numbers in the sequence. That is, those numbers when divided by 2 have a remainder of 0. Recall how to start the observable? Yep, we call the subscribe method. The observable then emits the range of numbers. We use an arrow function to define what we want to do with each item emitted from the pipeline. Here we simply log it. We'll talk more about the subscribe syntax and how to unsubscribe later in this module. What do you think will be logged to the console? The source emits 0, the 0 is multiplied by 3, resulting in 0. The 0 is divided by 2 with a remainder of 0, so it is included in the final result. The source emits 1, the 1 is multiplied by 3, resulting in 3. The 3 is divided by 2 with a remainder of 1, so it is not included in the final result, and so on. In the remainder of this module, we'll leverage observables to get and process data using HTTP.

Setting up an HTTP Request
We often encapsulate the data access for our application into a data service that can be used by any component or other service that needs it. In the last module, we did just that, but our product data service still contains a hardcoded list of products. We instead want to send an HTTP request to get the products from a back‑end web server. Angular provides an HTTP service that allows us to communicate with a back‑end web server using the familiar HTTP request and response protocol. For example, we call the get method of the HttpClient service, which returns an observable. When we subscribe to that observable, the HttpClient service sends a get request to the web server. The web server response is returned to the HttpClient service, and the observable emits the next notification, providing the response. What does this look like in code? This is the product.service we built in the last module. First, we specify a URL to the products on the web server. This defines where we send our HTTP requests. Note that this URL is shown for illustration purposes only and is not a real URL. Next we add a constructor. Recall from the last course module that we use a constructor to inject dependencies. In this case, we need Angular's HTTP service, wo we inject it here. And since we are strongly typing this variable to HttpClient, we import HttpClient here. Recall also from the last course module that before we can inject a service in as a dependency, we need to register that service's provider with Angular's injector. The HTTP service provider registration is done for us in the HttpClientModule. To include the features of this external package in our application, we add it to the imports array of our application's Angular module, AppModule. Recall that the declarations array is for declaring components, directives, and pipes that belong to this module. The imports array is for pulling in external modules. Now our Angular module illustration looks like this. We declare our components, we declare the directives and pipes that those components require, and we import the external modules that we need. Going back to the product.service, in getProducts we use the injected HTTP service instance and call the get method, passing in the desired URL. We specify the expected type of response by setting the get method's generic parameter. Recall that a generic parameter allows us to define a type for the data this method works with. Since we are expecting an array of products, we set the generic parameter to IProduct array. The get method then automatically maps the response returned from the back‑end server to the defined type so we don't have to. We aren't quite finished. What does our method now return? Since we are using strong typing, we should have a function return value. Here we define the get method generic parameter as IProduct array, so will that be what we get back? Not quite. The http.get method returns an observable, so we will receive a notification when the response returns from the back‑end server. Since this method returns the result of the http.get, and the http.get returns an observable, our method returns an observable. Because we told the HttpClient service to map the response to an array of product, our observable emits that array of products. We indicate that with the generic parameter. So our getProducts no longer returns an array of products. Instead, it returns an observable that will emit an array of products when the response is returned from the web server. Will this code then send the http.get request? Nope. Any idea why? This code returns an observable, and that observable won't do anything until we subscribe. We'll talk about subscribe in a few moments. For now, let's set up our HTTP request and our product.service.

Demo: Setting up an HTTP Request
In this demo, we'll set up an HTTP request to get the products for our product list page. We are looking at our application's Angular module we called AppModule. Recall from the slides that Angular registers its HTTP service provider in an Angular module called HttpClientModule. In our application's Angular module, we import that HttpClientModule. We then pull that module into our application by adding HttpClientModule to the imports array here. Now we can inject the Angular HTTP service into any class that needs it. Here is the product data service we created in the last module with all of the hardcoded data. We want to modify our product service to get the product data using HTTP. We want Angular to provide us an instance of the HttpClient service, so we identify it as a dependency in the constructor. We don't have a constructor yet, so let's add that first. Then we specify the parameter and add the import statement. Angular will then inject the HttpClient service instance into this variable. We need to identify the URL of the web server that we'll use to send the HTTP requests. We'll define a private property for that purpose. Hmm. This doesn't look like a valid URL to a web server. And to keep things simple, the demonstration reads the data from a local JSON file that was provided with the starter files. That way we don't need to set up an actual web server. However, we do need to define the location of this JSON file so that the Angular CLI can find it when it serves up the application. I've already done this in the provided starter files. Here in the angular.json file, we can see the path here in the assets array. To change this code to work against a web server, simply change this URL to point to an appropriate web server. And, of course, you need to write the server‑side code to return the list of products. Ah, it's finally time to delete our hardcoded data. So let's delete the hardcoded products from the getProducts method. Gone. We'll call the http.get method here instead, passing in the defined URL. We set the get method generic parameter to IProduct array. When we get a response back, this method will then automatically map the returned response to an array of products. We'll need to change the return type as well. Now this method returns an observable of IProduct array. And add the import statement. We can't try this out at this point because we are not yet subscribing to the observable returned from the service. Plus, looking at the console, we have a syntax error where we are calling this method since we changed the return type. Let's add some exception handling first, then modify the ProductListComponent to subscribe to the observable list of products.

Exception Handling
As you can imagine, there are many things that can go wrong when communicating with a back end service, everything from an invalid request to a lost connection. So let's add some exception handling. There are two key observable operators that we'll need. Tap taps into the observable stream and allows us to look at the emitted values in the stream without transforming the stream. So tap is great to use for debugging or logging. CatchError catches any error. We import them both from our rxjs/operators. As we discussed earlier in this course, to use these operators, we access the pipe method of the observable. We then pass in the operators, separated by commas. Here, the tap operator logs the retrieved data to the console. That way we can verify it's been retrieved correctly, and the catchError operator takes in an error handling method. The error handling method gets one parameter, the ErrorResponse object. In the error handling method, we can handle the error as appropriate. We can send the error information to a remote logging infrastructure or throw an error to the calling code. Now let's add exception handling to our product service. We are back in the editor with the product service just as we left it. This code is not really complete without the exception handling. So we'll add the appropriate imports for both the catchEr and tap operators. Recall that HttpGet returns an observable. We call the observable's pipe method to specify a set of operators. First, the tap operator, to access the emitted item without modifying it. The tap operator takes in an arrow function. The parameter is the emitted data, and the function defines what we want to do with that data. In this case, we log it to the console. Here we use JSON.stringify. JSON.stringify is a JavaScript method that converts an object or array of objects to a JSON string. This makes it easier to display in the console. We want to add a second operator so we insert a comma, then the catchError operator. The catchError also takes in a function, but this time we'll pass in a named function, or named method, instead of an arrow function. I'll paste in the handleError method and we need the import for HttpErrorResponse and throwError. In this method, we handle logging our errors any way we want. For our sample application, we'll just log to the console, and throw an error to the calling code. So our getProducts method is complete. We can add other methods here to post or put data as well. But we still have that syntax error here, and we can't see the result of our hard work, because we are not yet subscribing to the observable. Let's do that next.

Subscribing to an Observable
Observables are lazy. Just like a newspaper or a newsletter, an observable doesn't emit values until we subscribe. So when we are ready to start receiving values in our component, we call subscribe. The subscribe method takes an optional argument, which is an Observer object. As its name suggests, the Observer object observes the stream and responds to three types of notifications, next, error, and complete. We use the Observer object to define handler functions that execute on these notifications. The first handler function is often called a next function because it processes the next emitted value. Since observables can handle multiple values over time, the nextFn is called for each value the observable emits. The second is an error handler function, and, yep, you guessed it, it executes if there is an error. In some cases, we want to know when the observable completes, so observables provide a third handler that is executed on completion. The subscribe function returns the subscription. We use that subscription to call unsubscribe and cancel the subscription if needed. Now that our product data service is returning an observable, any class that needs product data, such as our product‑list.component, can call our service and subscribe to the returned observable. This line of code calls the product data service getProducts method, and because we subscribed, it kicks off the HTTP get request. It then asynchronously receives data and notifications from the observable. We pass an Observer object to the subscribe. This syntax defines a key and value pair, where the key is the function name and the value is the function, specified here using arrow function syntax. The first Observer function specifies the action to take whenever the observable emits an item. The method parameter is that emitted item. Since HTTP calls are single async operations, only one item is emitted, which is the HTTP response object that was mapped to our product array in the service. So the parameter is our array of products. This code then sets the local products property to the returned array of products. The second function is executed if the observable fails. In this example, it sets a local error message variable to the returned error. A third function, not used here, specifies the action to take when the observable ends with a completed notification. The third function is rarely used when working with HTTP requests, since they automatically complete after emitting the single response. It's good practice to always unsubscribe from any observable we subscribe to. There are several ways to unsubscribe. Here's one. First, store the observable subscription in a variable. Then implement the OnDestroy lifecycle hook that's executed when the component is removed from the display and destroyed. Lastly, use the subscription variable to unsubscribe. In the ngOnInit, we assign the observable subscription to a variable, then use that variable and the ngOnDestroy to unsubscribe. Now let's subscribe to and unsubscribe from our observable.

Demo: Subscribing to an Observable
In this demo, we modify our component to subscribe to the observable provided by the product service. And when the component is destroyed, we unsubscribe from the observable. Here in the product‑list.component, we see a syntax error. Now that we've changed the productService.getProducts method to return an observable, we can't assign the result of our product property directly, rather we subscribe to the returned observable. We call the subscribe method, passing in an observer object. The observer object provides functions for responding to our three notifications. Recall what those notifications are? Next, error, and complete. For the next notification, we define an arrow function to specify what we want to do when the observable emits the next value. And since this is an HTTP request, it only emits one time. When the array of products is returned in the response, we want to assign our local products variable to the returned array of products. But things don't always go as expected. To handle any errors, let's add an errorMessage property. We'll add it up here by our other properties. Then back down to the subscribe, add a comma, then we use the error notification to define what to do if the observable emits an error. In our case, we'll assign our local errorMessage property to the provided error string. Are we ready to try it out? Oh, we have no data. Why is that? Let's look again at our code. From the point of view of our application, HTTP is an asynchronous operation. What does that mean exactly for this code? Let's take it by the numbers. Angular first initializes the component and executes the ngOnInit method. We call the getProducts method of the productService. The productService returns an observable of IProduct array. We subscribe to that observable, and the HTTP GET request is submitted. This is the asynchronous operation. This code is then complete, and we execute the next line, which is setting our filteredProducts. But at this point, our products property is not yet set, so the filteredProducts is empty, and we see no data. At some future point in time, the service receives the HTTP response from our request. The response data is mapped to an array of products. The response is piped through any operators, and the observable emits that map data to any subscribers. Our subscriber receives the emitted data and assigns our product property to the emitted array of products. But since we are binding to the filteredProducts property, we are not notified that we now have the retrieved list of products. There are several ways we can handle this. One option is that we can move this line into the subscribe function. That way we won't assign the filteredProducts until the retrieved set of products are emitted from the service. Right now it's a single line function. To pass in a multiple‑line function, we need to add curly braces, like this, and let's not forget the semicolon. Now that it's a multi‑line function, we need to end each statement with a semicolon. Then we can move this line into the function. Now this line is executed after the products property is set to our list of products. Let's check it out. There are all of our products. Success! We have more here now because we are retrieving the products from the provided product.json file. If we open the developer tools, we see the data logged to the console here. Now that we have the subscribe working, let's be sure to unsubscribe. Back in the code, in the product‑list.component, implement the OnDestroy lifecycle hook by adding it to the implements here, and add the import statement. Then let's declare a variable for the subscription. We'll call it sub. It's of type Subscription, and we need the import statement. Now we have a problem here. You may recall, at the very beginning of this course, we talked about setting up our project to use TypeScript strict checking. That means we can't declare a variable without assigning it a default value. Let's look at our options. We can allow the variable to be undefined. This sets the data type of our variable to Subscription or undefined. So we could handle it that way. Undoing that, alternatively, we can define a TypeScript definite assignment assertion. The bang, or exclamation point, tells the TypeScript compiler that we will handle the assignment of this property sometime later. Since we plan to assign this variable in the ngOnInit, let's go with this option. In the ngOnInit method, we assign the variable we just created to the subscription returned when calling the subscribe method. We then defined the ngOnDestroy method that's required by the OnDestroy lifecycle hook and use the subscribe variable to call unsubscribe. Let's check it out to ensure it's all still working. Looking good. The recommended way to use HTTP is to encapsulate it in a service like our productService, then expose an observable for use by any component that needs product data. The component simply subscribes to the observable and at some later point in time gets the data or a notification. Let's finish up this module with some checklists we can use as we work with HTTP.

Checklists and Summary
Before we can use Angular's HTTP Client Service, some setup is required. We need to ensure that the service provider is registered with the Angular injector. This registration is done for us in the HttpClientModule. So all we need to do is pull the HttpClientModule into our application. We do this by adding HttpClientModule to the imports array of one of our application's Angular modules. Build a data access service to wrap HTTP requests. In that data service, define a dependency for the Angular HTTP Client Service using a constructor parameter. Create a method for each HTTP request. In the method, call the desired HTTP method, such as get, and pass in the URL to the desired server. Use generics to specify the response return type. This will transform the raw HTTP response to the specified type. Add error handling in the service as desired using the catchError operator. In any component that needs data from a data service, call the subscribe method to subscribe to the observable. Provide a function to execute when the observable emits an item. This often assigns a property to the returned data, and if that property is bound to a template, the retrieved data appears in the view. And add an error function to handle any returned errors. The component should unsubscribe from any observable it subscribes to. Store the subscription in a variable, implement the OnDestroy lifecycle hook, and use the subscription variable in the ngOnDestroy method to unsubscribe. Here are some related courses in the Pluralsight library. To perform create, read, update, and delete, or CRUD, operations using HTTP, see the Angular: Reactive Forms course. It demonstrates how to display, edit, and save data in Angular. For more information on RxJS and observables, see the RxJS in Angular: Reactive Development course. It provides a detailed look at observables, including how to combine data from multiple sources, build action streams to react to user actions, and work with streams without subscribing. See the Angular HTTP Communication course for intermediate HTTP techniques such as error handling, building interceptors, and testing HTTP requests We have now removed the hardcoded data from the product data service (yay) and instead retrieved the data using HTTP. In our sample application, we are using HTTP to retrieve the data from a local JSON file, but the techniques are the same for retrieving data from a back‑end service. Next up, we'll see how to display multiple pages with navigation and routing.

Navigation and Routing Basics
Introduction
A single view does not an application make. Welcome back to Angular: Getting Started, from Pluralsight. My name is Deborah Kurata, and in these next two modules, we define routes to navigate between multiple views in our application. As we design and build our application, we provide ways for the user to navigate its pages and features. With routing, we define the paths through the application and the user actions required to access each path. In this module, we start with an overview of how routing works in Angular. We examine how to configure routes and tie routes to actions, and we define where to place the routed component's view. Currently, our App component embeds our Product List component as a nested component. We instead want to define a set of routes so the user can navigate to the welcome view, product list view, or product detail view. We've already built the Product List component, and I've provided the Welcome component with the starter files in the GitHub repository for this course. As part of the demos in this module, we'll build the shell for the Product Detail component. When we're finished with this module, we'll have a simple application that routes to multiple views.

Generating Code with the Angular CLI
Before we jump into routing, we need more components so we have something to route to. I provided the WelcomeComponent as part of the starter files. Even though we won't be completing all of the features of the ProductDetailComponent, we will use it to illustrate key concepts, such as handling undefined and using route parameters. Let's build the ProductDetailComponent. The ProductDetailComponent should ultimately look like this, but we want to focus on routing, not building another component. So let's just create a shell for the ProductDetailComponent so we can route to it. We could use the Explorer and create new component class and template files manually. Or we could use the Angular CLI to automatically create those files. We installed the Angular CLI globally earlier in this course. If you didn't install it globally then, but want to try it out now, go back to the First Things First module and view the clip on creating an Angular application using the Angular CLI. To generate code using the Angular CLI, open the terminal. We already have the server running in this terminal, so let's click plus to open a second terminal. In the terminal, we type ng for the Angular CLI and g for generate. Next, we specify the type of file we want to generate. We'll type c for component and the name of our component. Since we want to create this component under the products folder, we add the path to the desired component name, so products/product‑detail following our naming convention. That's the basic syntax for generating a component with the CLI. But we can add flags for additional options. By default, Angular will create a new folder for this component. For the sample application, we want the contents of our product folder to be flat. We'll use the ‑‑flat option to achieve this. We'll learn much more about the Angular CLI later in this course. For now, press Enter, and the Angular CLI creates the component files for us, and it updated our Angular module. Yay! We can see here in the Explorer that it created the style sheet in a CSS file, the template in an HTML file, and the class in a TypeScript file. It even created the start of a unit test for us. Let's check out the generated template. Not much here. We'll replace the generated HTML with some placeholder text and use interpolation to bind to a page title. Next, let's look at the TypeScript file. The generated component has all the basic syntax in place. We can then add the properties that our component needs. We'll define a page title and set it to Product Detail. Notice that the CLI generated the selector property here. The selector property is only required if the component will be nested within another component. We won't need to nest this component. We'll instead display the component's view as part of the routing. So let's delete the selector. Now let's check out the Angular module. Notice that the CLI added the appropriate import and declared our new component. Very nice. Every time we add a component to the application, we need to declare the component in an Angular module. We currently have only one Angular module, AppModule. So the ProductDetailComponent and the WelcomeComponent must be added to the declarations array for the AppModule. If we use the Angular CLI as we did in this example, it automatically adds the appropriate declarations. Cool. If we don't use the CLI, like for our WelcomeComponent, we need to add the component to the declarations array ourselves. Let's do that now. We add the WelcomeComponent to the declarations array, then add the associated import statement. Now that we have the basic components in place, we are ready to add routing to our application.

How Routing Works
An Angular application is a single‑page application. That means all of our views are displayed within one page, normally defined in the index.html file. So each of the 5, 10, or 100s of views take turns appearing on that one page. How do we manage which view to display when? That's the purpose of routing. We configure a route for each component that wants to display its view on the page. As part of our application design, we provide a menu, a toolbar, buttons, images, or data links that allow the user to select the view to display. We tie a route to each option or action. When the user selects the option or performs the action, the associated route is activated, activating a component's route displays that component's view. Hmm. Let's look at that process again with an illustration. Here is the menu that we'll add to our sample application. We tie a route to each menu option using a built‑in router directive called routerLink. When the user clicks on the Product List option, for example, the Angular router navigates to the product's route. The browser's location URL changes to match this path segment, and we see /products appear in the address bar. By default, Angular uses HTML5 style URLs, which don't require the hash symbol to indicate local navigation. By using the HTML5 style URLs, you need to configure your web server to perform URL rewriting. How this is done depends on your web server. See the documentation for your web server on how to configure URL rewriting. Angular also supports hash style routing, which does not require URL rewriting. If you can't configure your web server and must use hash style routing, see the Angular documentation or the Angular Routing course here, in the Pluralsight library, for more information. When the browser's URL changes, the Angular router looks for a route definition matching the path segment, products in this example. The route definition includes the component to load when this route is activated, in this case the ProductListComponent. The Angular router then loads the component's template. Where does it display this template? Where we specified with a built‑in routing directive called router‑outlet. And the product list appears. So that's how routing works. We'll examine these steps in further detail and try them out in demos as we journey through this course module.

Configuring Routes
Routing is component‑based, so we identify the set of components that we want to provide as routing targets and define a route for each one. Let's see how this is done. An Angular application has one router that is managed by Angular's router service. Similar to the HTTP module, Angular provides a RouterModule in the Angular router package that registers the router service provider. In addition to registering the service provider, the RouterModule also declares the router directives. In the last clip, we mentioned two router directives, RouterLink and RouterOutlet. By importing the RouterModule, our component templates can use these or any other router directives. RouterModule also exposes the routes we configure. Before we can navigate to a route, we need to ensure that the routes are available to the application. We do this by passing the routes to RouterModule, like this. We call the RouterModule's forRoot method and pass our array of routes to that method. This establishes the routes for the root of our application. With that, we are ready to configure some routes. The router must be configured with a list of route definitions. Each definition specifies a route object. Each route requires a path. The path property defines the URL path segment for the route. When this route is activated, this URL path segment is appended to the URL of our application. The user can type in or bookmark the resulting URL to return directly to the associated component's view. In most cases, we also specify a component, which is the component associated with the route. It is this component's template that is displayed when the route is activated. These are all examples of route definitions. The first route simply maps a specific URL path segment to a specific component. So this URL displays the template from the ProductListComponent. The :id in the second route represents a route parameter. The Product Detail page displays the detail for one product, so it needs to know which product to display. The ProductDetailComponent reads the ID from this path segment and displays the defined product. We can define any number of parameters here, separated with slashes. What does this route do? Yep, this URL displays the template from the WelcomeComponent. This one defines a default route. The redirect here translates the empty route to the desired default path segment, in this example the welcome route. A redirect route requires a pathMatch property to tell the router how to match the URL path segment to the path of a route. We only want this default route when the entire client‑side portion of the path is empty, so we set the pathMatch to full. The asterisks in the last route denote a wildcard path. The router matches this route if the requested URL doesn't match any prior paths defined in the configuration. This is useful for displaying a 404 not found page or redirecting to another route. A few things to note here. There are no leading slashes in our path segments, and the order of the routes in this array matters. The router uses a first‑match‑wins strategy when matching the routes. This means that more specific routes should always be before less specific routes, such as the wildcard route. Ready to try this out?

Demo: Configuring Routes
In this demo, we configure the basic routes for our application. We are back in the sample application with the index.html file open. The first step to set up routing is to define a base element in the head tag of the index.html file. Notice that the Angular CLI already did that for us here. This element tells the router how to compose the navigation URLs. Since the app folder is the application root, we'll set the href for the base tag to /. Now we are ready to configure the route definitions. For that, we go to our Angular module. Add RouterModule to the imports array. Add the appropriate import statement. This registers the router service provider, declares the router directives, and exposes the configured routes. How does the RouterModule know about our configured routes? We pass them into the RouterModule by calling the forRoot method. We then configure the routes here, by passing them in using an array. Let's start with the product routes. For each route, we specify the path and a reference to the component. The template defined in the specified component will display when the router navigates to this path. For the product detail component route, we'll want a route parameter. That route parameter tells the component the ID of the product to display. Next we add the route to display our welcome page. We'll set the path to welcome and specify the WelcomeComponent. When the application loads, we want to default to the template from the WelcomeComponent, so we'll specify a default route that redirects to our WelcomeComponent. And let's define a wildcard path, in case the requested URL doesn't match any prior paths defined in the configuration. This is often used for displaying a 404 Not Found page, but in our simple example, we'll use it to redirect back to the welcome page. There's a lot of stuff here now in our root application module. In a later course module, we'll look at how to refactor this module into multiple Angular modules for a separation of concerns.

Tying Routes to Actions
With routing, the user can navigate through the application in several ways. The user can click a menu option, link, image or button that activates or navigates to a route. The user can type the associated URL segment in the address bar after the application URL or use a bookmark to that URL, or the user can click the browser's forward or back buttons. The route configuration handles the URLs, so the last techniques will just work. We need to handle the first technique by tying routes to the user actions. We need to decide how we will show the routing options to the user. We could display a navigation pane with links. We can provide a toolbar or images, or we can build a navigation menu like this one. In a more full‑featured application, the menu could have many more options and sub options, but this will do for our purposes. We define that menu as part of this component's template. We then need to tie a route to each menu option. We do that using the routerLink directive, and we enclose it in square brackets. The routerLink is an attribute directive, so we add it to an element such as the anchor tag here. Recall that a directive is custom syntax that we use to power up our HTML. In this case, it's providing our anchor tag with additional functionality to navigate to a route. We bind it to a template expression that returns a link parameters array. The first element of this array is the string path of a route. Additional elements can be added to this array to specify optional route parameters. The router uses this array to locate the associated route and build up the appropriate URL based on any provided parameters. If the array only contains the route path, we can use shortcut syntax like this. Here, we don't need square brackets. We can't use this syntax if the array contains multiple elements when passing parameters. When the user selects the option, the associated route is activated. Activating a component route displays that component's view. Now let's add a menu and use the routerLink directive so the user can navigate to the views in our sample application. Before we can begin, we need to decide how to show the routing options to the user. For our sample application, we'll build a menu. We want to add that menu at the root of our application, so we'll add it to the app.component. In the app.component template currently, we're nesting the product‑list .component using the product list component selector as a directive. We now want to route to the product‑list.component instead, so we delete the directive here. Since the product‑list.component will no longer be used as a directive, we can remove its selector. We'll delete it here. Going back to the app.component, we'll replace the remaining styles with a navigation menu. This menu uses the nav element tag and navbar classes from the Bootstrap styling framework we installed earlier in this course. Let's see how this looks in the browser. Here is our new menu, but clicking on the menu options don't do anything yet, and our product list no longer appears. We need to tie routes to these menu options. We'll use the routerLink directive to tie a route to each of these menu options. For the home menu option, we'll add the routerLink to the anchor element, but we could use any clickable element. We want to tie the welcome route to the home menu option, so we specify welcome here. Since we don't have any route parameters in this case, we can use the routerLink shortcut syntax here, which doesn't require square brackets. We'll use similar syntax to tie the product's route to the Product List menu option. Now we just need to tell Angular where to place our views and display the routed components template.

Placing the Views
When a route is activated, the associated component's view is displayed. But displayed where? How do we specify where we want the routed component to display its view? We use the router‑outlet directive. We place that directive in the host component's template. The routed components view then appears in this location. Let's add the router‑outlet to our sample application. We are back looking at the AppComponent. We add the router‑outlet in the template where we want to display the routed component's view. We'll put it here, and let's put a div element around it to give it some style. Whenever a route is activated, the associated component's view displays here. Let's see how that looks in the browser. Oh my, where did that page come from? That's the Welcome page provided in the starter files. When the application launches, the default route is activated, and the welcome view displays. If we click on the Product List menu, the router‑link directive now activates the product list route, and the Product List view appears. Sweet! Our application component can now route to multiple views. Notice the URL. The URL segment we defined for the route is displayed here. If we type in something, like Welcome, the WelcomeComponent's view is displayed. Let's open the developer tools and look at the HTML elements. Here we see our AppComponent pm‑route directive, our navigation bar, and our router‑outlet. Under the router‑outlet is the routed component. Opening it up, we see the header is Welcome. Clicking on the Product List menu option, we see the elements change. Opening it up again, we see the header is now Product List. As the user navigates through our application, the content below the router‑outlet is changed to display the template for the routed component. Now that we have our routing in place, let's review how these routing features work together. When the user navigates to a feature tied to a route with a routerLink directive, the routerLink uses the link parameters array to compose the URL segment. The browser's location URL is changed to the application URL plus the composed URL segment. The router searches through the list of valid route definitions and picks the first match. The router locates or creates an instance of the component associated with that route. The component's view is injected in the location defined by the router‑outlet directive, and the page is displayed. We now have basic routing in our sample application. Yay! As we've seen in this course module, routing is rather intricate, requiring code in multiple files and strings, such as parameter names and route paths that must match across those files. So let's finish up this module with some checklists that can help ensure all of the bits of routing are in the right places.

Checklists and Summary
To route or to nest? That is the question. When creating components, we need to think about how they will be displayed. For components designed to be nested within other components, we need to define a selector as part of the component decorator. The selector provides the name of the directive, and then we nest the component within another component, using the directive to define where the component template appears. The component does not then need a route. For components designed to be displayed as a view within our single application page, the component needs no selector, but we do need to configure routes. We then tie those routes to actions. An action activates a route to display the view. If we want to do routing in our application, we need to configure the route definitions, tie routes to actions, and place the view. Let's do checklists for each of these tasks. The first step for doing routing in an application is to configure the routes. Begin by defining the base element in the index.html file. Add RouterModule to an Angular module's imports array. Then add each route to the array passed to the router module's forRoot method, and remember that order matters. The router will pick the first route that matches. Each route definition requires a path, which defines the URL path segment for the route. Be sure the path has no leading slash. Use an empty path for a default route, and two asterisks for a wildcard route, which is matched if no prior path matches. Most route definitions also include a component. The component is a reference to the component itself. It is not a string name, and is not enclosed in quotes. Once we have the routes configured, we need to tie those routes to actions. First, we identify which actions to tie to which routes. Then we add the router length directive as an attribute to any clickable element in a component's template. We can use them in menu options, toolbars, buttons, links, images, and so on. Be sure to enclose the router link in square brackets. Bind the router link to a link parameters array. The first element of the link parameters array is the route's path. All other elements in the array are values for the route parameters. Use the RouterOutlet to identify where to display the routed component's view. This is most often specified in the host component template. When a route is activated, the route component's view is displayed at the location of the router outlet. Our app component had embedded our product list component as a nested component. In this module, we were finally able to remove that nesting. We set up routing so we can now navigate to our welcome and product list components. We've covered the basics of routing in this module, but there is so much more. In the next module, we'll look at some additional routing techniques, and add navigation to the product detail component.

Navigation and Routing Additional Techniques
Introduction
Now that we know the basics of routing, we are ready for more. Welcome back to Angular: Getting Started, from Pluralsight. My name is Deborah Kurata, and in this module, we look at several additional routing techniques. With what we learned in the prior module, a user can now navigate to any defined route in our application, but that only covered the very basic routing scenarios. What if we need to pass parameters to a route or activate a route with code instead of with a clickable element? Or what if we need to protect a route and only allow access to it in special cases or by certain users or ask a user to save changes before leaving a route? In the second module on routing, we examine how to pass parameters to a route, how to activate a route with code, and how to protect our routes with guards. When we're finished with this module, we'll know how to handle additional routing scenarios, including routing to a component that requires parameters such as our product detail component. Let's get started.

Passing Parameters to a Route
We sometimes need to pass parameters to a route, for example, to navigate to the product detail view, we need to define which products' details to display. The first step to passing parameters to a route is to configure the route with parameters. We've already done this step to route to our ProductDetailComponent. Here we define a slash, a colon, and a placeholder for the parameter. If multiple parameters are needed, we'd repeat this with another slash, colon, and placeholder. With the route definition in place, we can decide where we want the user to activate this route. Will we add a menu option or a data link? It is there we set the router link and pass in the required parameter. In the product‑list.component template, we display a table of products. Each table row contains the product name, so we add a routerLink to this anchor tag and assign it to the link parameters array. The first element of the array is the string path of the route. The second element of the array is the value for the route parameter. When the router composes the URL, it uses this array element to construct the defined parameter. Since we have a route parameter here, we can't use the short form routerLink syntax we used in the last module. We instead need to include square brackets for property binding here and assign it to an array with the routing path and parameter. To display the appropriate product, the ProductDetailComponent reads this parameter from the URL. It then uses the parameter to retrieve the appropriate product and display it in the view. To get the parameter from the URL, we use the ActivatedRoute service provided by the router. We want an instance of the service, so we define it as a dependency in our constructor. We've seen this syntax before. This line of code defines a private variable called route and assigns it to the instance of the ActivatedRoute provided by the Angular service injector. Then we use the instance of the activated route service to get the desired parameter. There are two ways for a component to read parameters from a route, depending on how the component behaves. If the component only needs to read the route parameter one time, we use the route's snapshot to access the paramMap and get the parameter. The snapshot gives us route information at a single point in time. We use this technique when the route doesn't change while displaying the component. For the ProductDetailComponent, the route parameter defines the product that the component displays. That parameter doesn't change while displaying the component. To change the viewed product, the user must leave the product detail page and pick another product from the product list page. If the component needs to redraw parameters as they change, we use the paramMap observable. Recall from earlier in this course that an observable is a collection of items that occur over time. We subscribe to the observable to receive notifications every time the parameters change. If our product detail component had next and previous buttons, the route could change without leaving the product detail page. Then we'd use the observable to respond every time the route parameters changed. Check out the Angular routing course for more information on getting route parameters using an observable. In both of these cases, the string specified in the get must match the parameter name from the route configuration path. Since the product detail component only needs to read the route parameter one time, let's try out the snapshot approach.

Demo: Passing Parameters to a Route
In this demo, we pass a parameter as part of the product‑detail route and read that parameter in the ProductDetailComponent. Here in the AppModule, we already have the ProductDetailComponent's route configured with a parameter. Looking at that route, here in the path, we provide any parameters prefixed with a colon and separated by slashes. For the ProductDetailComponent, we pass a product ID so the view knows which product's detail to display. Next, we need to decide where to tie this route to a user action. We can't add the product detail to the menu because we don't have an easy way for the user to specify the ID of the desired product. Let's instead modify the list of products in the product‑list view such that each productName is a link. Then the user can click on the product to display its details. In the product‑list template, we'll add an anchor tag so the productName becomes a link. We add the routerLink directive to the anchor tag and set up the link parameter's array. In the array, we define the path of the route to activate in the first element and pass the parameter value in the second element. In this example, we want to pass the product's ID. When we view the result in the browser, we see that the product names are now links, and if we click a link, we see the ID in the URL, and we navigate to the ProductDetailComponent. But that component does not yet get the parameter from the URL. Let's do that next. The ProductDetailComponent needs to read the route parameter so it knows which product's detail to display. The ActivatedRoute service provided by the router can help us. The ActivatedRoute service provides information on the state of the current route, including the route parameters. We set ActivatedRoute as a dependency by defining it as a parameter to the constructor function and add the needed import. The ActivatedRoute instance is then injected into this component class. The next question then is, Where do we put the code to read the route parameter? We don't want it in the constructor. We'll add it to the ngOnInit method provided by the OnInit lifecycle hook. Recall that the ngOnInit method is executed when the component is initialized. That's a good time to read the parameter and set the component properties based on that parameter. Since the parameter won't change while this component is displayed, we'll use the snapshot approach. We use the const keyword and declare an ID. Then we use the ActivatedRoute instance, access the snapshot of route information, and access the paramMap. Then we call the paramMap's get method passing in the name of the parameter to get. In our case, it's 'id.' Hovering over the 'id' variable, TypeScript defines it as a string or null, but since we're using it as a product ID, we want a number, so we'll add the number function around it. The ID is now a number. To make it easy to see the ID we read from the URL, let's display it as part of the page title. Here we use the ES 2015 backticks to define a template string and display the ID. Let's see the result in the browser. Click the menu option to display the product list, then click a product. The URL changes to include the parameter, and the Product Detail page is displayed. If everything worked, the title displays the same parameter as shown in the URL (yay). Before moving on, let's take a moment and talk about a common error we may run into involving undefined or null values and how to prevent it.

Handling Null and Undefined
In this demo, we look at a common error and how to prevent it by handling null and undefined. In the product detail template, we want to display the detail for one product. So in the product‑detail.component, let's declare a property for that product. We define its type using the product interface and add the associated Import statement. We see an error. We've seen this error previously. Because we are using TypeScript's strict type checking, we need to initialize this property. Let's try initializing it to an empty object. Hmm, that doesn't work. The error here is telling us that the empty object is missing the properties defined in our interface. So what do we do? We could use a TypeScript definite assignment assertion like we did last time we saw this error that tells the compiler that we plan to initialize this property later, but because we will ultimately get the product data using HTTP, there will be some delay in receiving the response to assign to this property. So let's be more explicit and mark the type as IProduct or undefined. The property is then clearly undefined until the data is retrieved. Then it's of type IProduct. In the product detail template, let's add the productName to the pageTitle. Open the terminal and we see an error, Object is possibly undefined. So now what? Here are two ways to prevent undefined property errors in our template. We could use the safe navigation operator defined with a question mark. The safe navigation operator guards against null and undefined values when navigating an object's properties. If the product object is null or undefined, the safe navigation operator simply returns null and does not attempt to access the product name property, hence, we won't see an undefined property error. The safe navigation operator is great, but it's not always the best option. For example, it doesn't work when used with the ngModel to a binding. It also can be quite tedious when we display many properties like in our ultimate product detail template. There is another option. We can use ngIf and check whether the product property is defined. We add the ngIf to an HTML element that encloses all references to the product object. If the product is undefined, this element and all of its children will not appear in the DOM, so it won't attempt to retrieve properties of an undefined product. Then we don't need the safe navigation operator. We can also use a combination of these approaches. We always want to display the title so we don't want an ngIf hiding this element. We'll use the safe navigation operator here instead. But for the product detail elements, we'll use the ngIf. We don't want to display any of the details, including any of the labels, if we don't yet have product data. Opening the browser and selecting a product, we see an empty page, but no error. The product name appears as null. Going back to the code, let's imitate an HTTP response by assigning a hardcoded product. I'll paste it in. If you are coding along, you can copy a product from the provided product.json file. Looking at the browser, we see our product name. Note that because we are hardcoding this product, we will see Leaf Rake, regardless of which product we select in the Product List page. Notice that every time we want to go back to the Product List page, we select the menu option, but it would be nicer to have a back button here. Next up, let's add a back button and see how to activate a route with code.

Activating a Route with Code
We want to add a Back button to our Product Detail page that navigates back to the Product List page. We could activate this route using the router link directive in the component template, just like we did with the menu options. But it's also possible to route with code. So let's try that out instead. When would you want to navigate with code instead of the router link directive and a template? One example is a Save button where you need to execute some code to save the data and then route. To route with code, we use the Router service. This is another service provided by the router. It allows us to work with the router in code. It's different from the ActivatedRoute service we used earlier in this module, which provided information on the activated route. We define a dependency on the Router service using a constructor parameter. The router instance is then injected into this component class. We use this router instance to activate a route. Here we define a method that we can call from the template based on a user action. The code uses the navigate method of the Router service and passes in the same link parameter array we use when binding the router link. In this example, we route to the products route and don't pass any arguments. Let's give this a try. We want the product‑detail.component to navigate back to the product‑list.component. Here in the product‑detail.component, we define the router as a dependency by adding another constructor parameter. Then add the needed import. When this component class is constructed, we'll get an instance of both the ActivatedRoute service and the Router service. Now we can build a method that navigates with code. Since the purpose of this method is to navigate back, we'll call it onBack. It doesn't return anything, so we'll set its return type to void. In this method, we use the router instance and call the navigate method. We pass it a link parameter's array. In this example, we want to navigate back to the product‑list.component, and we don't need any parameters. We just define the route path, which is products. In the product‑detail template, we'll add a Back button. We, again, use the Bootstrap style classes to give the button some style and add a Font Awesome icon. We use event binding to bind the click event of the button to the onBack method we defined in the class. Now let's check it out in the browser. Click on a product. The Product Detail page is displayed. We click our Back button, and we are back on the Product List page. Let's try another one. We see the Detail page. Now we're back on the Product List page. Our code‑based navigation is working. So routing with code involves importing the router and using its navigate method to activate the route. Now that we have several routes in place, let's look at how to protect them with guards.

Protecting Routes with Guards
There may be times that we want to limit access to a route. We want routes only accessible to specific users such as an administrator, for example, or we want the user to confirm a navigation operation such as asking whether to save before navigating away from an edit page. For that, we use guards. The Angular router provides several guards, including CanActivate to guard navigation to a route, CanDeactivate to guard navigation away from the current route, Resolve to prefetch data before activating a route, and CanLoad to prevent asynchronous routing. In this clip, we work through how to implement the CanActivate guard. You can use the same techniques we're covering here to implement any other type of route guard. We'll build a guard that prevents navigation to the product detail route, unless a specific condition is true. Building a guard follows the common pattern used throughout Angular, create a class, add a decorator, and import what we need. Here, we define a guard class. A guard is a service, so we use the @Injectable decorator and register the service with the root Angular injector by setting providedIn to root, and we import what we need. This class implements CanActivate to create one of the other kinds of guards, change this to implement one of the other guard types. We then implement the canActivate method. For simple cases, this method can return a boolean value, true to activate the route and false to cancel the route activation. For more complex cases, we could return an observable or a promise from this method. In the canActivate method, we write code to determine whether the user can access the route. This may involve checking the user's type to only allow an administrator to access the route, or it may involve checking the route parameters to ensure they are of an expected format before routing to the component. We built the guard to protect the product detail route, so we add the guard to the product detail route. We add canActivate and set it to an array containing the guards to execute before this route is activated. Let's give this a try.

Demo: Protecting Routes with Guards
In this demo, we protect our product detail route with a guard. We want to build a guard that prevents navigation to the ProductDetailComponent if the provided URL parameter is not valid. If I type 0 into the URL, I see the title display 0. But 0 is not a valid product ID. And if I type hello, we see NaN, which is short for not a number. Recall that the route definition for the ProductDetailComponent includes an ID, but there is nothing here that defines this ID to be numeric or greater than 0. So our guard should prevent navigation to the product detail route if the ID is zero or not a number. Our first step is to build our guard. We could build it manually, but why not use the Angular CLI? We open the integrated terminal and type ng for the Angular CLI, g for generate, g for guard, and the name of our guard. Since this guard is for the product detail route, we add it to the products folder, so products/product‑detail. That's all that is required. Press Enter, and the Angular CLI prompts us to select the type of guard we want to generate. We can select one or more guards. For our example, we only want the CanActivate guard. Press Enter, and we see that the CLI created the guard and the start of a unit test for that guard. Let's open the resulting guard. The CLI added all of the basic boilerplate here for us. Yay! Let's talk through it. Since a guard is a service, it needs to be registered with an Angular injector. The CLI registers this guard with the root application injector using the providedIn property. It implements the CanActivate interface and builds the start of the CanActivate method. The CanActivate method has two parameters, the ActivatedRouteSnapshot to provide current route information and the RouterStateSnapshot to provide router state information. The method can return an observable, a promise, or a simple boolean value. All that's left is to write the logic for the guard. What do we want this method to do? We need to check the route URL and ensure that the ID passed in is valid. If it is not valid, we want to navigate back to the Product List page. Navigation requires the router, so the first thing we need is a constructor. Then we inject in the router, letting VS Code import the appropriate package. Next, in the CanActivate, we need to read the parameter from the route. Luckily for us, CanActivate has a parameter that gives us the ActivatedRouteSnapshot. The ActivatedRouteSnapshot contains the information about a route at any particular moment in time. First, we use the const keyword to set the ID from the route parameter. Since route is an ActivatedRouteSnapshot, we can use its paramMap property to get the parameter using the parameter name. We again use the number function to convert the string parameter to a number. Then we use a JavaScript if statement to check the parameter. If the result is not a number or the value is less than 1, we display an alert. We don't normally want to display an alert from our application. In a real application, we'd route to an error page. That error page would notify the user of the problem and optionally provide a button for navigating back to the Product List page. But this is enough for our purposes. Then we activate a route with code and route to the Product List page. Note that this is the same code we used to activate a route with code that we saw in the last clip. Lastly, we return false to let the router know to cancel activating the product detail route. Otherwise, we return true and continue on to the Product Detail page. Now we are ready to hook up this guard to the appropriate route. So we open the file containing our remote configuration, which is our AppModule, and scroll down to the imports array. Let's first reformat the product detail route so it's easier to see. We add the CanActivate property to the route definition for the ProductDetailComponent and set it to an array. In this array, we specify each guard we want to execute when activating the route. In this case, we only have one. We add ProductDetailGuard and let VS Code add the import. Now let's try out our guard. If we view the Product List page and select a product, our URL is valid and we navigate to the page. If we instead type in a URL that is not a number, we see our message. The product detail route navigation is canceled, and we are redirected to the Product List page. It works. Use route guards anytime you want to prevent access to a route, confirm navigation away from a route, or preload data for a route. So let's finish up this module with some checklists.

Checklists and Summary
To prevent null and undefined errors in our templates, use the safe navigation operator denoted with a question mark. The safe navigation operator only navigates to the properties of an object if that object has a value and is not null or undefined. In this example, it won't access the product name unless the product property has a value. We can use the safe navigation operator to safely navigate down a chain of properties as well. Use the ngIf directive to remove an entire set of elements from a template if the value of a property is null or undefined. This is useful when accessing multiple properties or to also hide titles or labels. We can pass any number of parameters to a route. Add the parameter to the route configuration path by specifying a slash, a colon, and the parameter name. Pass the parameter value by adding it to an element of the link parameter's array bound to the routerLink directive. Read the parameter value in the navigated component using the ActivatedRoute service. Notice here that the parameter name, id in this example, is exactly the same as in the route definition. To activate a route with code, used the Router service and define it as a dependency on the constructor. Create a method that calls the navigate method of the Router service instance, and pass in the link parameters array. Add a user interface element and use event binding to call the created method. We can use guards to prevent access to a route, confirm navigation away from a route, or to preload data for a route. To create a router guard, we build a guard service. Implement the guard type, in our case canActivate, and create the associated method. We then register the guard service provider with the Angular injector, using the providedIn property set to root. Lastly, we add the guard to the desired route. If you are interested in learning more about routing, check out my Angular Routing course here, on Pluralsight. We now add routing to our Product Detail Component (yay). However, the Product Detail Component and its associated template are not finished. We only wired up the bare minimum to demonstrate routing. As a homework assignment, try building the remainder of the Product Detail template. At this point, our AppModule is looking a little cluttered and hard to manage. Up next, let's spend some more time with Angular Modules and look at how to refactor our application into more manageable pieces.

Angular Modules
Introduction
As we've seen throughout this course, Angular modules are a key part of any Angular application. Welcome back to Angular: Getting Started, from Pluralsight. My name is Deborah Kurata. And in this course module, we focus on Angular modules and how to use them to better organize our code. Oh, it's so beautiful. No, it's not a van Gogh, not even a Picasso, and yeah, it sort of looks like a metro map. This is a picture of what our application could look like if we leverage the power of Angular modules. Instead of one large AppModule like we have now, there are multiple modules, and each piece of our application has a logical place within one of those modules. This keeps each module smaller and more manageable. In this course module, we take another look at the definition and purpose of an Angular module. We then focus in on the Angular module metadata to better understand how to use it. We leverage that knowledge to create a feature module for our application and take it one step further, defining a shared module to reduce duplication. Lastly, we reexamine our application's root Angular module. Let's get started.

What Is an Angular Module?
What is an Angular module? As we've seen earlier in this course, an Angular module is a class with an NgModule decorator. Its purpose, to organize the pieces of our application, arrange them into cohesive blocks of functionality, and extend our application with capabilities from external libraries. Angular modules provide the environment for resolving the directives and pipes in our components templates. We'll talk more about this in a few moments. NModules are a great way to selectively aggregate classes from other modules and re‑export them in a consolidated convenience module. We'll create our own convenience module when we build a shared module a little later. An Angular module can be loaded eagerly when the application starts or it can be lazy loaded asynchronously by the router. Lazy loading is out of the scope of this course, but is discussed in detail in my Angular Routing course here, on Pluralsight. How does an Angular module organize our application? An Angular module declares each component, directive, and pipe that it manages. Every component directive and pipe we create belongs to an Angular module. An Angular module bootstraps our root application component, defining the component needed to display our first template. An Angular module can export components, directives, pipes and even other Angular modules, making them available for other modules to import and use. An Angular module imports other Angular modules, this brings in the exported functionality from those imported modules. Note that in this context and throughout this module, when I say imports, I mean added to the NgModule decorators imports array. I'm not referring to the import statement, though, we also need to add an import statement for each module we add to the imports array. We can think of an Angular module as a box. Inside that box, we declare each of our components. If the templates for those components need any functionality, that functionality also needs to be defined within this box. The AppComponent template sets up the routing for our main menu using routerLink and includes the router‑outlet directive, so the box needs the routing directives, router service, and routes, which are defined in RouterModule. The ProductList‑Component template uses ngModel, so the box needs the FormsModule. The ProductList‑Component template uses ngFor and ngIf, so the box needs the BrowserModule. The ProductList‑Component template uses the convertToSpaces pipe so the box needs that, too. The ProductList‑Component template also uses the starRating directive, so that must also be in the box, and so on until the box contains everything that each of our component templates need. Saying this another way, the Angular module provides a template resolution environment for each component that belongs to the module. It provides a way for the compiler to find and resolve the special Angular syntax we put into our HTML. We didn't need to think about template resolution much in our sample application up until now because all of the pieces of our application are in one Angular module, but we will need to keep this in mind as we split our application into multiple Angular modules. Let's take a quick look at our current app module. Here is the Angular module we defined throughout this course. It is the applications root Angular module, and by convention is called AppModule. The AppModule imports the system Angular modules we need, including the router module, which is where we configured our routes, it declares each component and pipe that we created in this course, and it bootstraps the application with the root application component, AppComponent. We have a lot of information in here, and we're mixing up basic application pieces, such as our WelcomeComponent, with pieces specific to our product feature. Let's journey through the NgModule metadata to better understand how Angular modules work so we can then refactor our AppModule into multiple modules for better code organization.

Bootstrap Array
As we have seen, every Angular application has at least one Angular module called the root application module, or AppModule, and an Angular application has at least one component called the root application component, or AppComponent. The AppModule bootstraps the AppComponent to provide the directive used in the index.html file. We covered the bootstrapping process in the introduction to ComponentsModules earlier in this course. The bootstrap array of the @NgModule decorator defines the component that is the starting point of the application. This is the component that is loaded when the application is launched. Here are some things to keep in mind when using the bootstrap array. Every application must bootstrap at least one component, the root application component. We do this by simply adding the root application component to the bootstrap array of the root application module. The bootstrap array should only be used in the root application module, AppModule. As we build other Angular modules, we won't use the bootstrap array.

Declarations Array
Every component, directive, and pipe we create is declared by an Angular module. We use the declarations array of the ngModule decorator to define the components, directives, and pipes that belong to this Angular module. Here are some things to keep in mind when using the declarations array. Every component, directive, and pipe we create has to belong to one and only one Angular module. In our sample application, all of our components are defined in one Angular module, AppModule. It would be better to divide the components into multiple modules with basic application pieces in the AppModule and feature pieces in appropriate feature modules. We'll do that a little later in this course module. As we separate out our pieces, it is important to remember that each component directive and pipe belongs to one and only one Angular module. Only declare components, directives, and pipes. Don't add other classes, services or modules to the declarations array. All declared components, directives, and pipes are private by default. They are only accessible to other components, directives, and pipes declared in the same module. So if we declare the StarComponent in Module B, by default, that component is not available to components in other Angular modules. We share components, directives, and pipes by exporting them. We'll talk more about exporting in a few moments. The Angular module provides the template resolution environment for its component's templates. When we include a component in the declarations array of an Angular module, the component belongs to that Angular module. That component's template, directives, and pipes are then resolved within that module. When we use a directive in a component's template, Angular looks to the module for the definition of that directive. If the component defining that directive is not declared within the same Angular module or exported from an imported module, Angular won't find the directive and will generate an error. For this example, the StarComponent must be declared in the same module as the ProductListComponent, or the StarComponent must be exported from an imported module, never both.

Exports Array
The exports array of the @NgModule decorator allows us to share an Angular module's components, directives, and pipes with other modules. We can export any of this module's components, directives, and pipes so they can be pulled in when another module imports this module using the imports array. We can also reexport system Angular modules such as FormsModule. We can reexport third‑party modules such as Material Design. Material Design is a set of high‑quality user interface components, including buttons and dialogs, and we can reexport our own modules. Here are some things to keep in mind when using the exports array. Export any component, directive or pipe if another component needs it. A module can export any of its declared components, directives or pipes. Reexport modules to reexport their components, directives, and pipes. This is useful when consolidating features for multiple modules to build a convenience or shared module. We can export something without including it in the imports array. The imports array only needs to import the modules that are required by the components declared in the module, but the Angular module can still provide capabilities to other modules that import it by reexporting. In this example, a SharedModule exports the FormsModule, even though it did not include it in its imports array. So any module that adds SharedModule to its imports array will have access to the ngModel and other forms directives. We'll see this in an upcoming demo.

Imports Array
An Angular module can be extended by importing capabilities from other Angular modules using the imports array. Many Angular system libraries are Angular modules such as the FormsModule and HttpClientModule we've used in this course. We can import Angular modules to use their capabilities. Many third‑party libraries are also Angular modules such as material design. We can import third‑party Angular modules to use their capabilities. We can import our own modules to extend our application with additional features or share capabilities across several modules. We'll see that in an upcoming demo. Here are some things to keep in mind when using the imports array. Importing a module makes available any exported components, directives, and pipes from that module. Recall that we are using ngModel in our ProductListComponent for two‑way binding. The ngModel directive is exported in the FormsModule. By importing the FormsModule into our AppModule, we can use ngModel in any component declared in our AppModule. Only import what this module needs. For each component declared in the module, add to the imports array what is needed by the component's template. Importing a module does not provide access to its imported modules. Hmmm, let's look at that with a picture. Here we have AppModule, which declares the ProductListComponent and a SharedModule that declares and exports the StarComponent. AppModule imports the SharedModule, so the SharedModule's exports are available to the AppModule's component templates. This means that the ProductListComponent can use the StarComponent directive. If the SharedModule imports FormsModule, then the FormsModule's exports are available to the SharedModule, and the StarComponent could use the ngModel directive. But the FormsModule exports are not available to the AppModule, so the ProductListComponent could not use the ngModel directive. I've heard this rule also stated another way, imports are not inherited. Note however, that if the SharedModule reexported the FormsModule, then the FormsModule exports are available to the AppModule, and the ProductListComponent could use the ngModel directive. Use the imports array to register services provided by Angular system modules such as HttpClientModule and RoutingModule or to register services from third‑party modules. Normally, we add a module that registers a service to the imports array of the AppModule. This ensures that services are registered one time when the application is initialized.

Providers Array
Angular modules can also register services for our application. We can use the providers array to register our services with the root application injector. However, this is no longer the recommended practice. Starting with Angular version 6, the recommended way to register our services is to use the providedIn property of the service itself, not the providers array of an Angular module. You may see older code use the providers array to register created services, but moving forward, use the service's Injectable decorator with providedIn set to root to register the service with the root Angular injector. Now that we've covered the basics of the NgModule decorator, let's refactor our application into multiple Angular modules.

Feature Modules
So far in this course, we've used the root application module, AppModule. It declares all of our components and our pipe. It imports the system Angular modules that our component templates need, but this is getting a little unwieldy. We have no separation of responsibilities. Here we are mixing our basic application features such as the WelcomeComponent with our product features such as the product components with our shared features such as the StarComponent. As we add more feature sets to this application such as customer management, invoicing, and so on, this is only going to get harder to manage. So let's reorganize and refactor to break this into multiple Angular modules. The first thing we want to do is extract some of these pieces into feature sets. We can then create a feature module for each feature set. Using feature modules helps us partition our application into logical groupings with separate concerns. Our first step is to define a new feature module. Creating a feature module involves defining a new module file, ProductModule in this example, and reorganizing the pieces of the application so that all of the associated feature pieces and everything they need are here in this module. In the declarations array of the feature module, we add the appropriate components that provide the features for the application. In this example, we add the ProductListComponent and ProductDetailComponent. Then, as we did with the box example at the beginning of this course module, we start to look at what each component's template needs. In this example, the ProductListComponent uses the pipe, so we need that. And both the ProductList and ProductDetailComponents use the StarComponent, so we'll need that here as well. But that's not enough. The ProductListComponent uses ngModel and ngFor, and both components use ngIf in routing. How do we get that? We import these needed capabilities from other Angular modules. Our product components use routing, so we import the system RouterModule. The ProductListComponent uses ngModel, so we import the system FormsModule, and we need ngFor and ngIf, so do we pull in the system BrowserModule? Nope. The BrowserModule should only be imported into the root application module, AppModule. Instead, we import the system CommonModule. The CommonModule exposes the ngFor and ngIf directives. Not surprisingly, the BrowserModule itself actually imports and exports the CommonModule, which is why we have access to ngFor and ngIf when we import BrowserModule in our AppModule. Our feature module is looking pretty good here, but now that we've removed these features from the root application module, how will the application find all of these features? What's that? Imports array did you say? That's correct. We need to import the ProductModule into the AppModule. That extends the AppModule with the ProductModule features. Want to try this out?

Demo: Feature Modules
In this demo, we'll build a feature module for our product features. We are back in the sample application. Here is our AppModule. Let's create a new feature module for our product feature. Want to try generating it with the Angular CLI? We open the integrated terminal. Let's stop the compiler because we'll want to restart after making these significant changes. Clear the console and type ng for the angular CLI, g for generate, m for module, and the name of our module. Since we are creating the ProductModule, we want it in the products folder, so products/product That's all that's required, but, by default, Angular will create a new folder for this module because it rightly assumes that we'll create the module when we define the feature and the feature folder. But we already have the products folder, so we'll use the ‑‑flat option. And we want to import this module into the AppModule to pull in its functionality. So we use the ‑m flag specifying the module name. Press Enter, and we see that the CLI created the module. It also updated our AppModule. We can see that here. It added ProductModule to our imports array (yay). Let's open the new ProductModule. The CLI already created the class with the @NgModule decorator and the required import statements. My version of the CLI created some extra empty lines. I'll delete them. Since this module is for our product features, in the declarations array, we add the ProductListComponent, ProductDetailComponent, ConvertToSpacesPipe, and StarComponent. Now we can remove these declarations from the AppModule. Going back to our ProductModule, we can see that the CLI already included CommonModule here since we need that in every feature module. We'll add the FormsModule and RouterModule. Now we can remove the FormsModule from the AppModule. When we added the RouterModule to the imports array and the AppModule, we called forRoot to pass in the configured routes for our Root Component. Now that we are adding the RouterModule to the imports array of a feature module, we don't call forRoot. Rather, we call forChild, and there we pass in the routes related to products. Let's cut the product routes from the AppModule and paste them here in our ProductModule and add the import statement for the ProductDetailGuard. Recall that the RouterModule registers the Router service provider, declares the router directives, and exposes our configured routes. But as we've discussed previously, we never want to register a service more than once. So when we use forRoot to pass in our configured routes, the RouterModule knows to register the Router service provider. When we use forChild, as we did here, the RouterModule knows not to reregister the Router service. Going back to the AppModule, let's delete our unused import statements. We can easily identify them as they are grayed out. Do you think our application will run? Open the terminal and restart the compiler with npm start. Click the Product List option, and our application still works as expected (yay). So we now have our first working feature module. But let's think about this for a moment. As we build our application, we'll build more features. Each logical set of features will have their own feature module, and each feature module will most likely need the CommonModule for common directives, such as ngFor and ngIf, the FormsModule for ngModel and two‑way binding, and we may have other features that want to reuse our StarComponent. Do we really want to repeat all of this in each feature module? There has to be a better way. Yep, we can define a shared module.

Shared Module
The purpose of a shared module is to organize a set of commonly used pieces into one module and export those pieces so they are available to any module that imports the shared module. This allows us to selectively aggregate our reusable components, and any external modules, and re‑export them in a consolidated convenience module. Creating a shared module involves defining a new module file, SharedModule in this example, and reorganizing the pieces of the application so that the shared pieces are here in this module. First, we add the components, directives, and pipes that we want to share throughout our application to the declarations array. In this example, we only want to add the StarComponent. Then we add to the imports array anything needed by the templates associated with the SharedModule's components. In this example, we import the CommonModule because our StarComponent template may need it. We don't import FormsModule because we don't need it here. If our StarComponent did use two‑way binding or we added another component here that did, we'd need to import FormsModule as well. We then need to export everything that we want to share. The exports array defines what this Angular module shares with any module that imports it. We export the StarComponent. That way, it is available to the components in any module that imports the SharedModule. We re‑export the CommonModule and FormsModule so their directives and other features are available to any module that imports the SharedModule. And notice here that we can export something without importing it first. A reminder that in this context when I say export something, I'm referring to adding that something to the exports array of the NgModule decorator. And when I say import something, I'm referring to adding that something to the imports array of the NgModule decorator. To use the SharedModule, we import it into every feature module that needs the shared capabilities, such as our ProductModule. Let's give this a try. We want to build a shared module, and we'll again use the CLI. Do you recall the correct CLI command to generate a module? We type ng for the Angular CLI, g for generate, m for module, and the name of our module. Since we are creating the SharedModule, we want it in the shared folder, so shared/shared. We already have the shared folder in place, so we'll specify the ‑‑flat option. That way, the CLI won't create another folder. And we want to import this module into the ProductModule to pull in its functionality, so we use the ‑m flag, specifying the module path and name. Press Enter, and we see that the CLI creates the SharedModule, and it updates our ProductModule. We can see that here. It added SharedModule to our imports array. Let's open the new SharedModule, and I'll again delete the extra empty lines. The CLI already created the class with the NgModule decorator and the required import statements, and it included CommonModule in the imports array here. Now, what did we want to share? Well, we want to share the StarComponent, so we add that to the declarations array here. To share the StarComponent, we need to export it. Let's add an exports array and export the StarComponent. There's a few more things that we want to share. So we don't have to import them into every feature module, we'll add CommonModule and FormsModule to the exports array. If there were other modules we wanted to share, such as ReactiveFormsModule or Material Design, we could add them here as well. We could also share the ConvertToSpacesPipe. I'll leave that up to you to add here if you wish. Now we can remove the StarComponent, CommonModule, and FormsModule from the ProductModule, along with their associated import statements, since these are now already accessible from the imported SharedModule. Are we good to go? Yep, our application comes up as it did before. Looking back at our code, notice now that our feature module, ProductModule, only contains product pieces and the SharedModule. And the SharedModule is clean, only including the pieces we want to share. We can reuse the SharedModule and any future feature modules as we add functionality to our application.

Revisiting AppModule
We now know that every application has a root application module that is, by convention, called AppModule. The main purpose of the AppModule is to orchestrate the application as a whole. And now that we've removed the feature and shared pieces from this module, its purpose is easier to see. Let's take another look. We've reduced the code in AppModule such that it now fits on one page. The AppModule normally imports BrowserModule. This is the module that every browser application must import. BrowserModule registers critical application service providers. It also imports and exports CommonModule, which declares and exports directives such as ngIf and ngFor. These directives are, then available to any of the AppModule's components' templates. We are also importing HttpClientModule to register the Angular HttpClient service provider. We import RouterModule and call forRoot, passing in the configured routes for the root of the application. Here we configure our default route and any wildcard routes, then we import each feature module. In this example, we have only one feature module, ProductModule. The declarations array identifies the list of components that belong to this module. In this example, the root component, AppComponent, and the application's WelcomeComponent are declared here. The bootstrap array identifies the root component, AppComponent, as the bootstrap component. When Angular launches the application, it loads this component and displays its template. Now let's finish up this course module with some checklists and a summary.

Checklists and Summary
When creating an Angular module, we build a class and decorate it with the NgModule decorator. The NgModule metadata is comprised of a set of arrays. The declarations array of the NgModule decorator declares the components that belong to this module. This array contains the list of components owned by the module. Declare each component of the application in one and only one module, and declare the custom directives and pipes used by the declared components unless they are already available from an imported module. The imports array of the NgModule decorator imports the modules that this module needs. This includes modules that provide components, directives, and pipes needed by templates associated with components declared in the module. For example, CommonModule and FormsModule, or our custom SharedModule. The imports array also includes modules that provide system or third‑party services, such as HttpClientModule. These modules are often only imported into the AppModule, so the services are only registered one time. And we pull in features from our feature modules by adding them to the imports array as well. We use the exports array of the NgModule decorator to define the pieces we want to share. This includes components, directives, and pipes, such as our StarComponent, and other modules, such as CommonModule or FormsModule. The exports array is often only used by shared modules. Lastly, the bootstrap array defines what the index.html file needs to start up the application. This is the component with the selector used in the index.html file. The bootstrap array is normally only used by the AppModule. If you are building a small application, such as the sample application we've created in this course, you may only need the one root application module as shown here. But as your application grows, you'll want to refactor into feature modules and shared modules, like this. Here, we organized our application into multiple modules. We have our feature module, ProductModule, that encapsulates all of the product features. There will be more feature modules as our application grows. We have our SharedModule that shares commonly used components, directives, and pipes with any module that imports it. Currently, we import it into the ProductModule. As we build more feature modules, we'll import it into them as well. And we have our AppModule that orchestrates the application. Each feature module is added to the AppModules imports array to extend the application with those features. Next up, let's take a peek at more of the features of the Angular CLI.

Building, Testing, and Deploying with the CLI
Introduction
We've mentioned the Angular CLI a few times in this course, but haven't really discussed what it is or what it can do. Welcome back to Angular: Getting Started from Pluralsight. My name is Deborah Kurata. And in this module, we look closer at the Angular CLI. Let's peek behind the curtain and learn more about this amazing tool. In this module, we start with an overview and discover the purpose and basic features of the Angular CLI. We then build an application using the CLI and examine the many configuration and startup files it creates. We dig into how it serves up our application, learn more about its code generation features, take a brief look at running tests, and prepare the resulting application for deployment. Let's get started.

Angular CLI Overview
The Angular CLI is a command line interface for Angular. Its primary purpose is to assist Angular developers with building an Angular application, generating Angular files, building and serving the resulting application, running tests, and building the application in preparation for deployment. The Angular CLI commands are access using ng for Angular, the command name, command arguments, and options prefixed with dash dash. For example, ng new hello‑world ‑‑prefix hw. As we saw earlier in this course, we often have the Angular CLI installed twice. We install it globally, so we have access to the ng commands from any folder. As new versions of Angular are released, we can update this globally installed Angular CLI. That way, as we create new applications with ng new, we use the latest Angular version. Angular automatically installs the Angular CLI locally in each Angular project. That way, the local version of the Angular CLI matches the version of the Angular project over time. We installed the Angular CLI globally earlier in this course. If you have not yet installed the CLI globally, do it now by opening a command window and typing npm install ‑g for global @angular/cli. Once you have it installed, we'll use it throughout this module. Let's jump into a demo. I've already installed the CLI. How can we find out what the CLI can do? One option is to use the ng help feature. Look at all those commands. Use the help command anytime you want to see the list of available commands or if you need assistance with the arguments and options for a specific command. One of my favorites is update. Using the update command, we can automatically update an Angular application to another version of Angular. It's a great way to keep your projects updated to the latest Angular version. See this link for more information. Let's try out the version command. Type ng and the command. We'll use the v alias, and we see a nice text output, including our Angular CLI version. When you watch this course, you may have a newer version. Now let's walk through how to use some of the key commands of the Angular CLI, starting with ng new.

Generating a New Angular Application (ng new)
We create a new Angular application using the Angular CLI new command. We used this command earlier in this course, but now let's take a closer look at all the files that it generates. Here in the command window, navigate to a folder for the new project folder. We'll type ng new and our new application name. Let's use a classic hello‑world, and let's specify a selector prefix of hw for hello‑world. The CLI has the ability to provide prompts to ask for more information. The CLI may add or change prompts, so your experience may vary from what you see here. It's asking whether we want to add Angular routing to the application. To keep things simple for our demo, let's answer no. Next, it asks which style sheet format we want. We'll select CSS and press Enter to select. After we answer the last question, the CLI generates our application. Now the CLI is automatically installing the packages defined in that package.json file. This takes a bit of time so I'll jump ahead. When the CLI new command is finished, we see a success message. Yay! The CLI creates a folder with the same name as the application name. Let's navigate down to the created hello‑world folder. I'll then use the shortcut code. to open this folder in VS Code. Starting at the top, the node_modules folder contains all of the libraries that were just installed by the CLI as defined in the package.json file. The src folder contains the source code for our application. Below it is the app folder where we'll add all of the modules, components, services, and other files for our application. The assets folder is for any images or assets we want to include with the application. In our APM project, our Welcome page logo and product images are in this folder. The environments folder sets up our build environments. By default, it generates two, one for development and one for production. The CLI picks the appropriate environment file based on the flags we use. The CLI comes with a default favicon. Nice. The index.html file is the first file downloaded when a user accesses our application. There isn't much here. You'd think that there would be at least a few script tags, but no. We'll see why a little later. In most cases, you won't need to ever modify this file. Notice that the Angular CLI uses the prefix we defined as the prefix for the directive here. Main.ts is the file that bootstraps our application. This is another file you should never need to modify. The polyfills file aids in supporting both evergreen and classic browsers. Polyfills add code to allow functionality written for modern browsers to work in older browsers. By default, it is set up to support evergreen browsers as stated here. If you need to target older browsers, there are comments in this file defining which additional libraries you need. Here is a style sheet for application‑wide styles. As its name suggests, the test file sets up for testing. That's it for the src folder. The browserlistrc file defines the list of browsers and browser versions that your application will support. It's used by the build system to build bundles appropriate for your supported browsers. The editorconfig file provides some standard settings for your editor. The gitignore tells Git which files to ignore for checking in to Git. Notice that our large node_modules folder is included in this list. The angular.json file is the CLI configuration file for our local install of the Angular CLI. This file is used to configure how the CLI generates code and works with our files. Throughout this course, we use stricter‑type checking in our sample application. This required that we specify data types, unless they could be inferred, and to assign a default value to every property and variable. The karma config file sets up Karma, which is a JavaScript test runner. We'll use that for our unit tests. We walked through the package.json file in the First Things First module earlier in this course. Here's a basic README. The tsconfig files are for TypeScript configuration. So that's an overview of the basic files created by the CLI new command. The next thing we want to do is run our application. So let's check out the serve command.

Serving the Application (ng serve)
Once we have a generated application, the first thing we may want to do is run it. We do that with the ng serve command. The ng serve command compiles the application, turning our templates and TypeScript code into JavaScript. It generates application bundles from that JavaScript. It starts a local web server that listens on port 4200. It serves the application from memory and rebuilds when we change any files. Let's see the command in action. We are back in the hello‑world application. Here in the terminal window, we'll type ng serve. Since this is the first time we are using the Angular CLI for this project, it asks if we want to share anonymous usage data. I'll say yes. The application is then built, and we can see that it compiled successfully. The CLI launches a development server and listens on port 4200. The compiler is now in watch mode, so it watches for any changes and automatically recompiles for us. So where is it? Where is our application? Click this link to open the application in your default browser. And here is the application. It has a slick Welcome page with links to the Tour of Heroes tutorial, the CLI documentation, and the Angular team's blog. In the package.json file that I included with the starter files for the APM sample application, I added ‑o to the start script. The ‑o is an alias for the ‑‑open flag, which opens the default browser. Let's stop execution and restart with the ‑o flag. We type ng serve ‑o, which automatically opens our default browser and navigates to our application. But we can go into our package.json and update it here if we'd like. Before we move on, let's take a moment and look more closely at the output of the ng serve process. When we use the ng serve command, the CLI builds the application and outputs it as a set of bundled JavaScript and map files. Here, we see the list of bundles. Vendor.js contains the Angular and third‑party libraries imported into our application. Polyfills.js contains the polyfills declared in the polyfills.ts file. Recall that this file contains the code needed to support a variety of browsers and browser features. These style files are our styles. Main.js contains our application code, and runtime.js is the Webpack loader. Webpack is the technology behind the compilation and bundling process. These files are generated in memory and are not available to find on disk. We'll generate actual files we can look at when we use the ng build command shortly. Going back to the browser, let's open the developer tools and view the Sources tab. We see those same bundles here on the left. And notice our index.html file. The CLI injected the needed script tags for us to pull down all of these bundles. Another mystery solved. Peeking inside the main bundle, we see something that looks a bit like our code transpiled to JavaScript. Unless we specify otherwise, all of our application code will be compiled into this bundle. Since the CLI also generated the associated map files, we can see down here in the webpack node that we have our actual TypeScript code. This makes it much easier to debug our code as we saw earlier in this course. Close the browser and use Ctrl+C to stop the development server. Now that we have an application and can run it, we'll want to add to it. Let's check out the generate command next.

Generating Code (ng generate)
Our new little application is cool and all, but it doesn't do much. We need to add components and templates and services and modules. We do that with the generate command. We've already seen this command in action, but it can do so much more. The Angular CLI generate command uses something called schematics to generate the requested code. According to the Angular documentation, a schematic is a template‑based code generator that supports complex logic. It's a set of instructions for transforming a software project by generating or modifying code. You can think of a schematic like a blueprint. Angular defines blueprints for generating specific kinds of code. Using the ng generate command leverages schematics for code generation. We can create components with templates and style sheet files as we did with the ProductDetailComponent earlier in this course. We can generate our own custom directives or route guards as we did with our product detail guard. We can create interfaces and modules. We can create pipes and services, all with only typing a few characters. Neat! Let's generate some code. Back in our hello‑world application, let's generate a component. Type ng g c and our component name, let's say welcome. The output indicates that it created a style sheet file, template HTML file, unit testing file, and TypeScript file for our component. And it updated the AppModule to add the new component to its declarations array. By default, it created a welcome folder and added these files to it. Next, we generate a service to manage our users. Type ng g s user. The output shows that it created the service and a unit test specification file for us. Now that we have more code, let's see how to run tests.

Testing the Application (ng test)
Testing our Angular code is always important, but often neglected due to the additional time and effort required to set up and execute the tests. The CLI makes it a bit easier by generating the testing spec and configuration files for us. We can run these tests using ng test to test each piece or unit of our code. To run our unit tests, in the terminal window, type ng test. This builds the application, launches the browser, and executes the Karma test runner. From here, we can see the results of our unit tests. Angular generated several tests for us, and they've all passed, so we are all green. The test runner runs in watch mode so we can modify our files, and the tests will immediately rerun. I'll close the browser, and notice that I tried to bring it up again. I first need to terminate the test runner with Ctrl+C, then I'll clear the screen with cls. Testing is a big topic that is beyond the scope of this course. See the Pluralsight library for more information about testing. Now that we have our application built and tested, we are ready to deploy.

Building the Application (ng build)
An application is not very useful unless you can deploy it to your users. The build command helps you prepare your application for deployment. Let's take a look. When we deploy to production, there are a few more things that we want to achieve. We want our bundles to be as small as possible. This means that we want to minify or uglify the code and perform something called tree shaking. Tree shaking shakes up our code to drop out any dead branches, which basically means that it removes any unused pieces. The CLI will do all of these things for us. Here in the terminal window, we'll type ng build. When the build is complete, we see the list of generated bundles. Notice that they now have a hash as part of the final name. This is done for cache busting. Every time we update something in our code, it needs to be redeployed to the server. We expect the new version of the files to be downloaded by the browser when a user accesses our application. But for performance reasons, the browser may have cached those files. By changing the file names using a hash, the browser will download the latest version because the file names won't match its cached versions. When the ng build process is complete, we have a dist folder here in our project. If we open this folder, we see our actual bundles. Notice also that there are no map files here. By default, the build command does not generate map files, but there is a flag for that if you need them. Peeking into the main bundle, all the code is on one line. And look at those variable names. It's been minified. Glad we don't have to debug using that code. And here is the resulting index.html file with the script tags to pull in each bundle. We can then deploy these files to a server somewhere. Wow, the CLI is powerful. Now let's finish up this module with some checklists we can use as we leverage the Angular CLI.

Checklists and Summary
Here are the key CLI commands for reference. Use ng help or ng, a command name, ‑‑help to view the CLI documentation. The remaining commands here help you create, execute, build, test, and deploy your Angular application and keep them updated to the current Angular version. You may find yourself using ng generate a lot. Refer to this checklist as you generate the code files for your application. There are more commands and many more flags than what we discussed in this module. To learn more about the Angular CLI, check out John Papa's course aptly entitled Angular CLI in the Pluralsight library. It covers many more of its amazing features. Up next, let's finish our journey with some final words.

Final Words
Introduction
As you have seen throughout this course, Angular provides a consistent set of patterns for building components, templates, and services, helping us come up to speed quickly. Welcome back to Angular: Getting started, from Pluralsight. My name is Deborah Kurata, and the final words in this course include a recap of our journey, tips for enhancing your development experience, and a few pointers to additional information. Let's jump right into this short module.

Recapping Our Journey
The goal of this course was to guide you down the right path, making your own adventures with Angular more pleasant and productive. Let's recap our journey and review the answers to the key questions we identified at the beginning of this course. What is a component? We discovered that a component is a view defined with a template, logic defined with a class, and metadata defined with a decorator. Where do we put the HTML for our user interface? Either in the metadata using the template property or in a separate HTML file using the templateUrl property in the metadata. When should we use binding? Any time we want to display a component class property value in the view, when we want to control the DOM by setting a DOM element property in code, when we want to respond to user actions, and when we want to display a component class property and update the property when the user makes a change. Why do we need a service? We uncovered several reasons for building a service, to implement functionality that is independent from any particular component, to share data and logic across components, and to encapsulate external interactions, such as with data access. And how, how do we build an Angular application? With code that looks like this, export a class, attach a decorator, and import what we need. Then put each component directive and pipe in its appropriate Angular module's declarations array. As the application grows, break out features into feature modules and share common code with a shared module. To aid productivity, leverage the Angular CLI for creating, executing, generating, and testing your application and to build it in preparation for deployment. Along the way, each module provided a set of checklists. They contain steps and tips. Feel free to revisit and reference these checklists as you start building your own Angular applications. Download the slides, including these checklists, using the Exercise files tab on the Pluralsight page for this course.

Enhancing Your Development
Let's look at some tools and tips for enhancing your development experience with Angular. Consider installing the Angular Language Service extension for VS Code. This extension provides a rich editing experience for Angular templates, including IntelliSense and error messages. With this extension installed, when you bind a product property in the template and type product., you'll get the list of valid properties. And if you mistype a property name in a template, you'll get a squiggly line and an error message. As your application gets bigger, it may take longer for it to download and for the users to see its first page. You can improve your application's load time performance with lazy loading. When you implement lazy loading, the feature modules for your application can load asynchronously after the first page is loaded. Find out more in the Angular Routing course here, in the Pluralsight library. Angular provides a rich set of techniques for building and validating user entry forms. See the Angular Forms and Angular Reactive Forms courses on Pluralsight for details. Leverage your observable pipelines. Many Angular projects work with multiple sets of data. Learn and use the RxJS operators to effectively combine, merge, and process multiple datasets. See the Pluralsight RxJS and Angular Reactive Development course for more information. Many projects have unique architectural elements, and many teams have specific coding standards and styles. You can modify existing schematics or create your own Angular CLI schematics to generate code the way you want it. See the Angular documentation for more information. Consider installing the Angular DevTools Chrome extension. The Angular DevTools provide debugging and profiling capabilities specifically for Angular applications. And with TSLint now deprecated, you can add ESLint features to your project using the Angular CLI ng add command. See this GitHub repo for more information.

Learning More
This course covered the basics, but there is so much more. On Pluralsight, the Angular CLI course covers more about the Angular CLI. The Angular Forms and Angular Reactive Forms cover building and validating data entry forms with Angular. And the Reactive Forms course details basic CRUD, or create, read, update, and delete operations using HTTP. For more information on RxJS and observables, check out the RxJS in Angular: Reactive Development course. In the Angular Routing course, you'll learn how to define complex routes, lazy load routes for better performance, and more. Angular component communication provides effective solutions for passing data between components. This course teaches you numerous communication techniques and, more importantly, which to use when. Angular Fundamentals expands on the basics and covers more intermediate information on every key aspect of Angular. In addition, the Angular documentation is very comprehensive and is a great reference to everything Angular.

Closing
Congratulations! You've made it. Yay! You've completed the journey through the basics of Angular. But the road goes ever on and on. There are so many more paths for us to take and so much more to learn. Thoughts or comments about this course? Please use the Discussion tab on the Pluralsight page for the course to leave your feedback. And follow me on Twitter. It would be great to hear about your Angular adventures. Thanks for listening, and I hope you enjoyed our adventure through Angular.